{
  "data": [
    {
      "id": "https://juejin.cn/post/7566088386521546794",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "字节出手！「Vue Native」真的要来了！",
      "url": "https://juejin.cn/post/7566088386521546794",
      "pubDate": "Wed, 29 Oct 2025 01:18:26 GMT",
      "description": "就在前几天，字节跳动开源的“大杀器”--Lynx.js 火了。\n号称要把 Vue 带进原生世界，让全球 200 万 Vue 开发者直接“零成本”变身 Native 工程师。\n\nWeex 之后，Vue 移动端「空白十年」\n严格来说，Vue 官方从未发布过名为 \"Vue Native\" 的框架。\n2017 年阿里 Weex 曾让 Vue 写原生成为现实，但维护力度递减；\n2018 年社区出现的**「vue-native-core」**只是基于 React Native 的薄层封装，2021 年便停更。\n自此，Vue 开发者想在移动端打出**「原生体验」**这张牌，只能投向第三方方案：\nNativeScript-Vue\nIonic Vue + Capacitor\nuni-app / uni-appx\n老牌选手集体升级——「Vue Native」储备军\n就在字节 Lynx 刷屏的同一个月，几条「低调却重磅」的更新悄悄发布：\n\nNativeScript-Vue 3.0 正式支持 Vite 热重载与 esbuild 构建，启动时间从 10s 级降到 1s 级；全新 @nativescript/tailwind 让原生控件也能用 Tailwind 语法，开发体验直追 Web。\n\nIonic Vue 7 带来 Standalone Components，完全摆脱 Angular 影子；配合 Capacitor 5 的 background-runner 插件，可在后台线程跑 JS，卡顿问题大幅缓解。\n\nuni-app 正式开放 uni-appx —— 把 Vue SFC 编译成 Kotlin/Swift 的原生代码，脱离 WebView，性能对标 Flutter；华为、阿里小程序已率先接入。\n换句话说，「Vue 写原生」这条赛道从未消失，只是从「单选题」变成了「多选题」。\n黑马入场：字节 Lynx 的「王炸」在哪里？\n与上面「WebView → 原生」的渐进路线不同，Lynx 一出生就是原生渲染 + 双线程架构：\n\nUI 线程：自研 PrimJS 引擎 + Rspeedy（Rust 版 Rspack）→ 首帧瞬间直出。\n后台线程：跑业务逻辑、网络请求，复杂计算不卡界面。\n框架中立：模板语法依旧是 HTML/CSS，但渲染端是 iOS/Android 原生控件，性能与 Flutter 同一梯队。\n真实战绩：TikTok 搜索、直播、剪映（CapCut）部分页面已用 Lynx 重构，月活 10 亿+ 场景验证。\n更关键的是，Lynx 团队公开喊话：\n\"We'd love to see Vue on Lynx. PRs are welcome!\"\n\n于是 GitHub 出现 vue-lynx-prototype，目标只有一个——让 Vue SFC 直接编译成 Lynx 的双线程包。\n抢先尝鲜：Vue + Lynx 代码长什么样？\n下面给出一段可直接跑通的 Hello World 示例，方便大家感受「Vue 语法 + Lynx 原生渲染」的写法。\n注意：<view>、<text>、<image> 为 Lynx 原生标签，会被编译成对应平台的真实组件；\n其余语法与标准 Vue 完全一致。\n<!-- HelloLynx.vue -->\n<script>\n// 支持 ESModule，可直接 import 图片、JSON 等静态资源\nimport lynxLogo from './assets/lynx-logo.png'\n\nexport default {\n  name: 'HelloLynx',\n  data() {\n    return {\n      title: 'Hello Vue-Lynx',\n      msg: '双线程原生渲染，首帧直出！',\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n      // 这里运行在后台线程，不会阻塞 UI\n      console.log(`[background] count = ${this.count}`)\n    }\n  }\n}\n</script>\n\n<template>\n  <!-- <view> 等价于原生容器，支持 flex 布局 -->\n  <view class=\"container\">\n    <!-- <image> 会被编译成 UIImageView / android.widget.ImageView -->\n    <image :src=\"lynxLogo\" class=\"logo\" />\n\n    <!-- <text> 对应 UILabel / TextView，只能包裹文本 -->\n    <text class=\"h1\">{{ title }}</text>\n    <text class=\"p\">{{ msg }}</text>\n\n    <!-- 事件绑定与 Web 一致 -->\n    <button class=\"btn\" @click=\"increment\">\n      点我：{{ count }}\n    </button>\n  </view>\n</template>\n\n四种技术路线，怎么选？\nNativeScript-Vue\n渲染：真正的 iOS/Android 原生控件\n性能天花板：★★★★（接近原生）\n开发体验：刚接入 Vite，秒级热重载 + Tailwind 支持，\"写 Vue 就像写 Web\"\n生态/插件：直接调用原生 API，Cordova/Capacitor 插件也能复用\n适合场景：需要 100% 原生 UI 和原生能力，且团队对 NativeScript 无抵触\nIonic Vue\n渲染：WebView（可叠加 PWA）\n性能天花板：★★★（足够展示类、电商类应用）\n开发体验：最贴近 Web，组件库成熟，一键生成 App/小程序/PWA\n生态/插件：靠 Capacitor 打通相机、蓝牙、推送等原生功能\n适合场景：追求\"同一套代码覆盖 Web + 多平台小程序 + App\"，对极致性能不敏感\nuni-app / uni-appx\n渲染：默认 WebView，uni-appx 可编译为 Kotlin/Swift 原生代码\n性能天花板：★★★☆（uni-appx 可到 ★★★★）\n开发体验：CLI、云开发、插件市场一条龙，国内文档最友好\n生态/插件：微信、支付宝、百度、QQ、抖音小程序全覆盖\n适合场景：业务主战场在国内，需要一次发布多端小程序，同时 App 也要能上架\nVue + Lynx（社区原型）\n渲染：真正的双线程原生渲染（iOS/Android）\n性能天花板：★★★★☆（TikTok 亿级验证）\n开发体验：即将对接 Vite/Rspeedy，目前需手动配置；生态几乎为零\n适合场景：从 0 开始的新项目、对首帧和动画极度挑剔、字节系流量场景或愿意共建生态的团队\n一句话总结：\n\"现在就要\" → 选 1 或 3\n\"最像 Web\" → 选 2\n\"性能极致 + 愿意尝鲜\" → 冲 4\n「Vue Native」真的要来了？\n如果你今天就要上线，NativeScript-Vue 3 的 Vite 版已是生产可用；uni-appx 则适合国内小程序+App 一起发。\n如果你追求极致性能且能接受早期生态，Lynx 社区正在招募贡献者：编译器、路由、DevTools、TypeScript 声明……每个 PR 都可能成为官方标准。\n也许再过一年，我们不用再讨论「该选哪个框架」——\nnpm create vue-native@latest 一条命令，\nLynx + Vue 双线程模板，\nNativeScript-Vue 的 Vite 脚手架，\nuni-appx 的原生工程。\n无论哪条路线，「Vue 写原生」不再是空白——Weex 的遗憾，终将在 2025 被填补",
      "hotIndex": 1,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7565876621653573659",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "没开玩笑，全框架支持的 dialog 组件，支持响应式",
      "url": "https://juejin.cn/post/7565876621653573659",
      "pubDate": "Tue, 28 Oct 2025 09:00:09 GMT",
      "description": "前言\n朋友们好啊，我是 auto-plugin 掌门人德莱厄斯。\n刚才有个朋友问我，德老师发生什么事了，我说怎么回事，给我发了几张截图，我一看，嗷！原来是昨天，有两个小项目，两三个页面，一个只有表单收集页，一个是登录页加信息页。他们说，唉...有一个说是他不想在这种小项目中引入大型组件库，徳老师你能不能教教我 auto 功法，哎帮助开发一下，我的小项目。我说可以，我说你老用组件库大力出奇迹，不好用，他不服气。我说小朋友，你一个组件库来用在我 vue 和 react 上，他说用不了。他说你这也没用。我说我这个有用，这是统一，传统开发是讲究一次编译到处运行。二百个组件的大型组件库，掰不动我这一个小组件。\n啊...哈，他非和我试试，我说可以。哎...我一说啪一下就给 element-plus 引入了，很快啊！然后上来就是一个 message，一个 tooltip，一个响应式布局。我全部防出去了啊，防出去以后，自然是传统开发点到为止，autohue 藏在 github 没给他看。我笑一下准备上班。由于这时间，按传统开发的点到为止他已经输了，如果 autohue 发力，一下就把他组件库打散架了，放在 github 没给他看，他也承认，说组件库没有这种功能。啊，我收手的时间不聊了，他突然袭击说 dialog 你没有，啊，我大意了啊，没有做。哎，他的 dialog 给我脸打了一下，但是没关系啊！他也说，啊他截图也说了，两分多钟以后，当时流眼泪了，捂着眼说，我说停停。然后两分钟以后，哎两分钟以后就好了，我说小伙子你不讲武德你不懂，说徳老师对不起对不起，我不懂规矩。啊，他说他是乱打的，他可不是乱打啊，mmessage、tooltip 训练有素，后来他说他练过两年开源，啊，看来是有备而来。这两个年轻人不讲武德，来骗，来偷袭！我 26 岁的老同志，这好吗这不好，我劝！这位年轻人耗子尾汁，好好反思，以后不要再犯这样的聪明，小聪明啊。啊，呃...开发要以和为贵，讲究统一，不要搞窝里斗，谢谢朋友们。\ndialog 的场景往往出现在表单收集、确认问询的场景，在 JQ 时代，我们可能很常用浏览器自带的 alert，但是这东西会阻塞主进程，且样式也不太好控制，或者用 bootstrap 的组件。到了框架时代，出现了各种组件库，但是它们都存在几个问题\n要用必须全量安装（虽然现在大家都支持树摇）\n修改样式比较麻烦\n不支持跨框架，感知不统一\n他们跟自身生态、框架生态深度绑定，虽然大多数时候我们用起来很方便，心智负担也很低。但是他们不可避免地出现了上述三个问题。\n那么如果像我刚才提到的，只做一两个页面的简单应用，也要引入组件库吗，要是引入组件库，你还要画两分钟思考一下，你要用 vue 生态还是 react 生态的。那有人说了，现在组件库也是跨框架支持啊，下载对应的包就行了，但是你看，截至目前2025年10月28日，ant-design 的 vue 版本还停留在 4.26 ，而 react 版本已经到了 5.27.6(BTW:antd for react 组件库现在已支持 autofit.js)。容易发现，使用不同的框架，即使是同一个组件库，不同框架开发体验也是不同的。\n这在多元化我们的选择的同时，也割裂了开发的生态。\n碰巧我最近又在写一个简单项目，需要一个 dialog 组件，我又讨厌原子化 css 的写法（这就是为什么不直接用 shadcn 的原因），怎么办呢，再实现一个得了。\nautodialog.js\ngithub: github.com/Auto-Plugin…\n我取名可不是瞎取的（也瞎取过），这个 autodialog.js 是真正的框架无关的 dialog 组件。那么它的 auto 体现在哪呢？它可以自动识别传入的弹窗内容是来自什么框架！甚至不会破坏 vue 的响应式和 react 的状态，你甚至可以在 原生 html、svelte、solid、augular 中无缝使用，而不破坏框架本身的特性。更惊奇的是，调用方法是一模一样的。\n在说实现思路之前，我想让你先感受一下 autodialog.js 的使用\n快速使用示例\n原生 HTML\nimport autodialog from 'autodialog.js'\n\nautodialog.show('<div>Hello World!</div>')\n\nVue 3\nimport autodialog from 'autodialog.js'\nimport MyDialog from './MyDialog.vue'\n\nautodialog.show(MyDialog, {\n  props: { title: '你好 Vue' })\n\nReact 18+\nimport autodialog from 'autodialog.js'\nimport MyDialog from './MyDialog.tsx'\n\nautodialog.show(MyDialog, {\n  props: { message: '你好 React' }\n})\n\n666 有没有？autodialog.js 内部自动判断了传入的组件类型，使无论什么框架的调用方式都完全一致！\n\n而且除了遮罩和最简单的动画外（当然也提供了自定义方式），其余样式完全由你的内容决定！你完全无需写多层选择器或者使用 !important 来覆盖样式。\n原理解析\n要实现这种跨框架，又保留框架特性，又保持感知统一的工具库，其实有一条成熟且稳妥的道路，那就是适配器(adapter)\nautodialog.js 也是这样，它的 core 包是纯 js 的，但是接受各种各样的适配器，我定义的适配器格式如下：\n/**\n * 适配器接口\n * - render: 渲染内容到 panel 上\n * - unmount: 卸载 panel 上的内容（可选）\n */\nexport interface Adapter {\n  render: (content: any, options: { container: HTMLElement; panel: HTMLElement;[key: string]: any }) => void\n  unmount?: (panel: HTMLElement) => void\n}\n\n比如要实现一个 vue 的适配器就是这样：\nimport { createApp, h, type Component } from 'vue'\n\ninterface VueRenderOptions {\n  panel: HTMLElement\n  title?: string\n  props?: Record<string, any>\n  onClose?: () => void\n}\n\nexport const VueAdapter = {\n  render(Component: Component, { panel, title, props = {}, onClose }: VueRenderOptions) {\n    // 创建一个 Vue 应用实例\n    const app = createApp({\n      render() {\n        return h('div', { class: 'autodialog-vue-wrapper' }, [\n          title ? h('div', { class: 'autodialog-header' }, title) : null,\n          h(Component, { ...props, onClose }),\n        ])\n      },\n    })\n\n    // 挂载到 panel\n    app.mount(panel)\n    ;(panel as any)._vueApp = app\n  },\n\n  unmount(panel: HTMLElement) {\n    const app = (panel as any)._vueApp\n    if (app) {\n      app.unmount()\n      delete (panel as any)._vueApp\n    }\n  },\n}\n\n\n当然，autodialog.js 已经内置了 vue 和 react 的适配器。\n如果你使用 svelte，autodialog.js 没有内置，那么你可以使用适配器注册器函数来外部挂载一个适配器，像下面的章节（进阶使用）里就实现了一个 svelte 适配器。\n你完全不必担心适配器很难写，因为你使用你熟悉的框架，如果你熟悉 vue，那么看一下上面的 vue 适配器，它也只是使用了 vue 的 render 和 h 函数。\n在 autodialog.js 的 core 中，是这样自动判断内容来自什么组件，该用什么适配器的：\n  /** \n   * 自动检测逻辑（detect 不强制\n   */\n  private detectAdapter(content: any): Adapter {\n    // 1️⃣ 优先使用用户注册的自定义适配器\n    for (const { detect, adapter } of Dialog.customAdapters) {\n      try {\n        // detect 可省略：省略则直接匹配\n        if (!detect || detect(content)) return adapter\n      } catch { }\n    }\n\n    // 2️⃣ 内置适配器兜底\n    if (typeof content === 'string' || content instanceof HTMLElement || content instanceof DocumentFragment)\n      return HtmlAdapter\n\n    if (content && (typeof content === 'object' || typeof content === 'function')) {\n      const proto = (content as any).prototype\n      const hasSetup = !!(content as any).setup\n      const hasRender = !!(content as any).render\n      const isClass = proto && proto.isReactComponent\n      const isFunctionComponent = typeof content === 'function' && /^[A-Z]/.test(content.name)\n      if (hasSetup || hasRender) return VueAdapter\n      if (isClass || isFunctionComponent) return ReactAdapter\n    }\n\n    throw new Error('[autodialog] Unsupported component type.')\n  }\n\n内置的 vue 和 react 适配器是直接检查了各自组件对象的特征，从而实现自动拾取适配器，自定义适配器则要写一个 detect 函数（特征检查），当然这不是必须的，因为你在你的框架中只会有一种组件传入，所以不必检查特征，detectAdapter 函数会优先拾取你的自定义适配器。\nautodialog 有一个单例的默认导出，你可以直接导入使用，也可以引入 Dialog 类，实现多例弹窗。\n所谓大道至简，核心原理就只有这些内容了！\n进阶使用\nAPI\nautodialog.show(content, options?)\n\n选项类型默认值说明\n\ntitlestringundefined可选标题\npropsobject{}传递给组件的参数\nshowMaskbooleantrue是否显示遮罩层\nallowScrollbooleanfalse是否允许滚动页面\nanimationbooleantrue是否启用动画\nanimationDurationnumber200动画持续时间（毫秒）\nanimationClass{ enter?: string; leave?: string }-自定义动画类名\nonBeforeOpen() => void-打开前\nonOpened() => void-打开后\nonBeforeClose() => void-关闭前\nonClosed() => void-关闭后\nonMaskClick() => void-点击遮罩层时触发\n\n自定义适配器（例如 Svelte）\nimport { Dialog } from 'autodialog.js'\nimport { mount } from 'svelte'\n\nexport const SvelteAdapter = {\n  render(Component: any, { panel, props = {}, onClose }: any) {\n    const instance = mount(Component, {\n      target: panel,\n      props: { ...props, onClose }\n    })\n    ;(panel as any).__svelte__ = instance\n  },\n  unmount(panel: HTMLElement) {\n    const inst = (panel as any).__svelte__\n    inst?.destroy?.()\n    delete (panel as any).__svelte__\n  }\n}\n\n// ✅ 注册自定义适配器（detect 可省略）\nDialog.registerAdapter({\n  name: 'svelte',\n  adapter: SvelteAdapter\n})\n\n现在可以直接这样调用：\nimport MyDialog from './MyDialog.svelte'\nautodialog.show(MyDialog, { props: { text: '来自 Svelte 的弹窗 ✨' } })\n\n设计理念\nAutodialog 的设计遵循三个核心原则：\n框架独立：核心逻辑不依赖 Vue、React 或其他框架。\n可扩展性：任何渲染系统都可以通过 Adapter 接入。\n用户主导：样式、动画与生命周期完全开放给用户控制。\n结语\n希望 auto-plugin 的插件能给你带来帮助，让我们欢迎新成员：autodialog.js !\ngithub：github.com/Auto-Plugin…\nnpm:www.npmjs.com/package/aut…\n别忘了免费的小星星点一点。",
      "hotIndex": 2,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7565811094734389248",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "我删光了项目里的 try-catch，老板：6",
      "url": "https://juejin.cn/post/7565811094734389248",
      "pubDate": "Tue, 28 Oct 2025 04:21:33 GMT",
      "description": "相信我们经常这样写bug（不是 👇：\n\ntry {\n  const res = await api.getUser()\n  console.log('✅ 用户信息', res)\n} catch (err) {\n  console.error('❌ 请求失败', err)\n}\n\n看似没问题\n每个接口都要 try-catch，太啰嗦了！\n错误处理逻辑分散，不可控！\n代码又臭又长💨！\n\n💡 目标：不抛异常的安全请求封装\n我们希望实现这样的调用👇：\nconst [err, data] = await safeRequest(api.getUser(1))\nif (err) return showError(err)\nconsole.log('✅ 用户信息：', data)\n\n\n是不是清爽多了？✨\n🧩 实现步骤\n1️⃣ 先封装 Axios 实例\n// src/utils/request.js\nimport axios from 'axios'\nimport { ElMessage } from 'element-plus'\n\nconst service = axios.create({\n  baseURL: import.meta.env.VITE_API_BASE_URL,\n  timeout: 10000,\n})\n\n// 🧱 请求拦截器\nservice.interceptors.request.use(\n  (config) => {\n    const token = localStorage.getItem('token')\n    if (token) config.headers.Authorization = `Bearer ${token}`\n    return config\n  },\n  (error) => Promise.reject(error)\n)\n\n// 🧱 响应拦截器\nservice.interceptors.response.use(\n  (response) => {\n    const res = response.data\n    if (res.code !== 0) {\n      ElMessage.error(res.message || '请求失败')\n      return Promise.reject(new Error(res.message || '请求失败'))\n    }\n    return res.data\n  },\n  (error) => {\n    ElMessage.error(error.message || '网络错误')\n    return Promise.reject(error)\n  }\n)\n\nexport default service\n\n拦截器的作用：\n✅ 统一处理 token；\n✅ 统一处理错误提示；\n✅ 保证业务层拿到的永远是“干净的数据”。\n2️⃣ 封装一个「安全请求函数」\n// src/utils/safeRequest.js\nexport async function safeRequest(promise) {\n  try {\n    const data = await promise\n    return [null, data] // ✅ 成功时返回 [null, data]\n  } catch (err) {\n    return [err, null] // ❌ 失败时返回 [err, null]\n  }\n}\n\n这就是关键！\n3️⃣ 封装 API 模块\n// src/api/user.js\nimport request from '@/utils/request'\n\nexport const userApi = {\n  getUser(id) {\n    return request.get(`/user/${id}`)\n  },\n  updateUser(data) {\n    return request.put('/user', data)\n  },\n}\n\n4️⃣ 在业务层优雅调用\n<script setup>\nimport { ref, onMounted } from 'vue'\nimport { userApi } from '@/api/user'\nimport { safeRequest } from '@/utils/safeRequest'\n\nconst user = ref(null)\n\nonMounted(async () => {\n  const [err, data] = await safeRequest(userApi.getUser(1))\n  if (err) return showError(err)\n  console.log('✅ 用户信息：', data)\n})\n</script>\n\n是不是很优雅、数据逻辑清晰、不需要 try-catch、 错误不崩溃。\n老板说：牛🍺，你小子有点东西\n\n🧱 我们还可以进一步优化：实现自动错误提示\n我们可以给 safeRequest 增加一个选项，让错误自动提示：\n// src/utils/safeRequest.js\nimport { ElMessage } from 'element-plus'\n\nexport async function safeRequest(promise, { showError = true } = {}) {\n  try {\n    const data = await promise\n    return [null, data]\n  } catch (err) {\n    if (showError) {\n      ElMessage.error(err.message || '请求失败')\n    }\n    return [err, null]\n  }\n}\n\n使用时👇：\nconst [err, data] = await safeRequest(userApi.getUser(1), { showError: false })\n\n这样你可以灵活控制是否弹出错误提示，\n🧠 进阶：TypeScript 支持（超丝滑）\n如果你用的是 TypeScript，可以让返回类型更智能👇：\nexport async function safeRequest<T>(\n  promise: Promise<T>\n): Promise<[Error | null, T | null]> {\n  try {\n    const data = await promise\n    return [null, data]\n  } catch (err) {\n    return [err as Error, null]\n  }\n}\n\n调用时：\nconst [err, user] = await safeRequest<User>(userApi.getUser(1))\nif (user) console.log(user.name) // ✅ 自动提示类型\n\n老板：写得很好，下次多写点，明天你来当老板",
      "hotIndex": 3,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7565733796269981738",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "iOS 26 开始强制 UIScene ，你的 Flutter 插件准备好迁移支持了吗？",
      "url": "https://juejin.cn/post/7565733796269981738",
      "pubDate": "Tue, 28 Oct 2025 03:40:47 GMT",
      "description": "在今年的  WWDC25 上，Apple 发布 TN3187 文档，其中明确了要求：“在 iOS 26 之后的版本，任何使用最新 SDK 构建的 UIKit 应用都必须使用 UIScene 生命周期，否则将无法启动” ：\n实际上 UIScene 不是什么新鲜东西，反而是一个老古董，毕竟它是在  iOS 13 中引入的，它的核心思想是将应用的“进程”生命周期和“UI 实例”的生命周期分离，让应用可以同时管理多个独立的 UI 实例 。\n而在此之前，iOS 主要围绕单体模型  UIApplicationDelegate  来实现生命周期管理，例如：\n负责处理应用进程的启动与终止 application(_:didFinishLaunchingWithOptions:) / applicationWillTerminate(_:)\n所有与 UI 状态相关的事件，例如应用进入前台并变得活跃 (applicationDidBecomeActive(_:)) 或进入后台 (applicationDidEnterBackground(_:))\n窗口管理 AppDelegate 拥有并管理着应用唯一的 UIWindow 实例\n处理系统级事件，包括响应远程推送通知、处理通过 URL Scheme  如 Deeplink 等\n所以可以明显看到，这种单体模型的架构最根本的缺陷在于，将应用进程与 UI 界面紧密绑定，导致整个应用只有一个统一的 UI 状态。\n但是这在之前对于 Flutter 来说并没有什么问题，因为 Flutter 默认本身就是一个单页面的架构，虽然存在 UIScene  ，但是  AppDelegate 就满足需求了，所以在本次迁移到 UIScene 生命周期之前，Flutter 在 iOS 平台上的整个原生集成都围绕着 UIApplicationDelegate 构建 ，而随着本次 TN3187 的要求，Flutter 不得不开始完全迁移到  UIScene  模型。\n对于  UIScene  模型，整个逻辑主要入了三个概念：\nUIScene：代表应用 UI 的一个独立实例，绝大多数情况下开发者熟悉的就是 UIWindowScene，它管理着一个或多个窗口以及相关的 UI\nUISceneSession：持久化对象，它代表一个场景的配置和状态，比如即使其对应的 UIScene  实例因为资源回收等原因被系统断开连接或销毁，UISceneSession 依然存在，保存着恢复该场景所需的信息，是实现状态恢复的关键\nUISceneDelegate：作为 UIScene 的代理，它专门负责管理特定场景的生命周期事件，例如连接、断开、进入前台、进入后台等\n所以到这里，可以很明显看出来，UIApplicationDelegate  和  UISceneDelegate 有了进一步的明显分割：\nUIApplicationDelegate  ：处理进程级别的事件，比如应用启动和终止的，并负责处理推送通知的注册等全局任务\nUISceneDelegate ：接管了所有与 UI 相关的生命周期管理，包括场景的创建与连接 (scene(_:willConnectTo:options:))，活跃 (sceneDidBecomeActive(_:))；进入后台 (sceneDidEnterBackground(_:))；以及断开连接 (sceneDidDisconnect(_:))  等\n具体大概会是以下的关系变化：\n\nAppDelegateSceneDelegate新增范围与职责转移关键行为差异\n\napplication(_:didFinishLaunchingWithOptions:)scene(_:willConnectTo:options:)application(_:configurationForConnecting:options:)从 AppDelegate 转移到 SceneDelegate，AppDelegate 仍处理非 UI 的全局初始化（如三方库配置），SceneDelegate 负责创建 UIWindow 和设置根视图控制器AppDelegate 的 didFinishLaunchingWithOptions 在应用冷启动时仅调用一次，SceneDelegate 的 willConnectTo 在每个场景（窗口）创建时都会调用。\napplicationDidBecomeActive(_:)sceneDidBecomeActive(_:)-从应用级转移到场景级，AppDelegate 的方法在场景模型下不再被调用sceneDidBecomeActive 针对单个场景，允许对不同窗口进行独立的激活处理\napplicationWillResignActive(_:)sceneWillResignActive(_:)-从应用级转移到场景级，AppDelegate 的方法在场景模型下不再被调用sceneWillResignActive 针对单个场景，例如当一个窗口被另一个应用（如 Slide Over）遮挡时触发\napplicationDidEnterBackground(_:)sceneDidEnterBackground(_:)-从应用级转移到场景级，AppDelegate 的方法在场景模型下不再被调用sceneDidEnterBackground 允许对每个场景的状态进行独立保存。\napplicationWillEnterForeground(_:)sceneWillEnterForeground(_:)-从应用级转移到场景级，AppDelegate 的方法在场景模型下不再被调用sceneWillEnterForeground 在应用冷启动时也会被调用，而 applicationWillEnterForeground 不会。这是迁移过程中常见的逻辑错误来源\napplication(_:open:options:)scene(_:openURLContexts:)-从应用级转移到场景级，AppDelegate 的方法在场景模型下不再被调用scene(_:openURLContexts:) 接收到的 URL 会被路由到最合适的场景进行处理\napplication(_:continue:restoreHandler:)scene(_:continue:)-从应用级转移到场景级scene(_:continue:) 允许为特定场景恢复用户活动状态\napplicationWillTerminate(_:)sceneDidDisconnect(_:)application(_:didDiscardSceneSessions:)applicationWillTerminate 仍表示整个应用的终止，sceneDidDisconnect 表示场景被系统回收资源（可能重连），didDiscardSceneSessions 表示用户通过应用切换器关闭了场景（永久销毁）职责更加细化，sceneDidDisconnect 不等于应用终止，而 didDiscardSceneSessions 是清理被用户主动关闭的场景资源的入口。\napplication(_:didReceiveRemoteNotification:fetchCompletionHandler:)--职责保留在 AppDelegate，推送通知是进程级事件，不与特定 UI 实例绑定即使在场景模型下，推送通知的接收和处理逻辑仍然主要位于 AppDelegate\n\n而对于 Flutter Framework 层面的变化，主要有：\n引擎渲染逻辑：Flutter 需要修改 GPU 线程的管理方式，之前引擎主要是根据 UIApplication 的全局通知来暂停或恢复渲染，而迁移后必须改为监听基于单个 UIScene 的通知，以正确处理多窗口下的渲染暂停和恢复\n废弃 API 替换：引擎和框架代码中之前使用了 UIApplication.shared.keyWindow API 来获取应用的窗口，这些调用都必须被替换\n插件注册机制：由于 FlutterViewController 的创建时机发生变化，插件的注册和关联 FlutterEngine 的机制也需要重构，确保在正确的时机与正确的引擎实例关联\n而对于Flutter 插件来说， 任何依赖于 UI 生命周期事件或需要与 UI 窗口交互的插件都可能受到了影响，Flutter 官方对第一方插件进行了大规模的迁移 ：\nurl_launcher_ios：需要获取当前窗口来呈现浏览器视图\nlocal_auth_darwin：进行生物识别认证时需要与 UI 交互\nimage_picker_ios：需要呈现图片选择界面\ngoogle_sign_in_ios：需要弹出登录窗口\nquick_actions_ios：处理主屏幕快捷操作，其回调方法从 AppDelegate 转移到了 SceneDelegate\n\n而对于 Flutter 应用开发者，Flutter 提供了一条自动化和通用的手动迁移方式：\n1、自动化迁移（推荐）：如果你的 Flutter 项目的原生 iOS 部分（ios 文件夹）没有经过大量定制化修改，可以使用 Flutter CLI 提供的实验性功能来自动完成迁移。\n在终端中运行以下命令，开启 UIScene 自动迁移开关\nflutter config --enable-uiscene-migration\n\n然后正常地构建或运行你的 iOS 应用\n         flutter build ios\n         ///or\n         flutter run\n\n在构建过程中，Flutter 工具会检查项目配置，如果符合条件会自动执行以下操作：\n修改 AppDelegate.swift（或 .m），移除过时的 UI 生命周期回调\n在 ios/Runner/ 目录下创建一个新的 SceneDelegate.swift（或 .h/.m）文件继承自 FlutterSceneDelegate\n更新 Info.plist 文件，添加必要的 UIApplicationSceneManifest 配置\n迁移成功后，会在构建日志中看到 \"Finished migration to UIScene lifecycle\" 的提示，如果项目过于复杂无法自动迁移，工具会给出警告，并提示你进行手动迁移\n2、手动迁移：对于那些有复杂原生代码、自定义 AppDelegate 或其他特殊配置的应用，需要手动迁移：\n修改 AppDelegate.swift：\n打开 ios/Runner/AppDelegate.swift，删除所有与 UI 生命周期相关的方法，例如 applicationDidBecomeActive、applicationWillResignActive、applicationDidEnterBackground、applicationWillEnterForeground （可以参考前面的表格）\n保留 application(_:didFinishLaunchingWithOptions:) 方法，但确保其中只包含应用级的初始化逻辑（如注册插件、配置三方服务），移除所有创建和设置 window 的代码\n确保 AppDelegate 类继承自 FlutterAppDelegate（如果之前不是的话），或者遵循 FlutterAppLifeCycleProvider 协议\n创建 SceneDelegate.swift：\n在 Xcode 中，右键点击 Runner 文件夹，选择 \"New File...\" -> \"Swift File\"，命名为 SceneDelegate.swift\n将以下代码粘贴到新文件，这段代码定义了一个最简的 SceneDelegate，它继承 FlutterSceneDelegate，从而自动获得了将场景生命周期事件桥接到 Flutter 引擎的能力\n      import UIKit\n      import Flutter\n\n      class SceneDelegate: FlutterSceneDelegate {\n        // 你可以在这里重写 FlutterSceneDelegate 的方法\n        // 来添加自定义的场景生命周期逻辑。\n      }\n\n更新 Info.plist：\n打开 ios/Runner/Info.plist，在根 dict 标签内，添加以下 UIApplicationSceneManifest ：\n<key>UIApplicationSceneManifest</key>\n<dict>\n    <key>UIApplicationSupportsMultipleScenes</key>\n    <false/>\n    <key>UISceneConfigurations</key>\n    <dict>\n        <key>UIWindowSceneSessionRoleApplication</key>\n        <array>\n            <dict>\n                <key>UISceneConfigurationName</key>\n                <string>Default Configuration</string>\n                <key>UISceneDelegateClassName</key>\n                <string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>\n            </dict>\n        </array>\n    </dict>\n</dict>\n\n迁移自定义逻辑：\n如果你之前在 didFinishLaunchingWithOptions 中有创建 Method Channels 或 Platform Views 的逻辑，这些逻辑都需要迁移，因为在 didFinishLaunchingWithOptions 执行时，FlutterViewController 可能还不存在\n一个更好的位置是在 SceneDelegate 的 scene(_:willConnectTo:options:) 方法，或者创建一个专门的初始化方法，在场景连接后调用，Flutter 的建议将这类逻辑移至 didInitializeImplicitFlutterEngine 方法\n最后就是“天见犹怜”的插件开发者，对于插件作者而言 UIScene 迁移带来了更大的挑战：必须确保插件既能在已经迁移到 UIScene 的新应用中正常工作，也要能在尚未迁移的旧应用或旧版 iOS 系统上保持兼容，例如：\n一个依赖生命周期事件的插件（例如，一个在应用进入后台时暂停视频播放的插件）不能简单地把监听代码从 AppDelegate 移到 SceneDelegate，这样做会导致它在未迁移的应用中完全失效，因此插件必须能够同时处理两种生命周期模型\n具体插件迁移步骤：\n注册场景事件监听：在插件的 register(with registrar: FlutterPluginRegistrar) 方法中，除了像以前一样通过 registrar.addApplicationDelegate(self) 注册 AppDelegate 事件监听外，还需要调用新的 API 来注册 SceneDelegate 事件的监听，Flutter 提供了相应的机制让插件可以接收到场景生命周期的回调\n实现双重生命周期处理：插件内部需要实现 UISceneDelegate 协议中的相关方法，在实现时要设计一种优雅降级的逻辑。例如同时实现 applicationDidEnterBackground 和 sceneDidEnterBackground，当 sceneDidEnterBackground 被调用时，执行相应逻辑并设置一个标志位，以避免 applicationDidEnterBackground 中的逻辑重复执行（如果它也被意外调用的话）\n更新废弃的 API 调用：插件代码中任何对 UIApplication.shared.keyWindow 或其他与单一窗口相关的废弃 API 的调用都必须被替换\n例如 url_launcher_ios 插件的迁移： ，在 UIScene 之前，当需要弹出一个外部浏览器窗口时，它可能需要获取应用的 keyWindow 作为视图层级的参考：\n// 迁移前\nif let window = UIApplication.shared.keyWindow {\n    // Use window to present something...\n}\n\n///迁移后\n// Accessing the window through the registrar, which is scene-aware.\nif let window = self.pluginRegistrar.view?.window {\n    // Use the scene-specific window...\n}\n// A more robust approach for finding the key window in a scene-based app\nlet keyWindow = self.pluginRegistrar.view?.window?.windowScene?.keyWindow\n\n这个例子可以看到，插件从直接访问全局单例 UIApplication.shared.keyWindow，转变为通过与插件关联的 pluginRegistrar 来获取视图 (view)，再从该视图向上追溯到其所在的 window 和 windowScene，最终找到正确的窗口。\n所以对于插件开发者来说，需要适配不同版本的 Flutter 来完成工作，无疑加大了成本。\n这其实也在一定程度来自于历史技术债务，因为其实 UIScene 是很早前就存在的 API ，但是由于 Flutter 场景的特殊性，默认  UIApplicationDelegate  一直满足需求，而面对这次 iOS 的强制调整，历史债务就很明显的爆发出来，特别是对于社区第三方开发者的适配成本。\n不过好消息是，我们还有时间，而全新的 Flutter  3.38.0-0.1.pre 也才刚刚出来，但是这对 Flutter 下个版本的稳定性也是一个挑战，因为这也是一个底层较大重构。\n参考链接\ndeveloper.apple.com/documentati…\ndocs.flutter.dev/release/bre…",
      "hotIndex": 4,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7565176027909095470",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "我带的外包兄弟放弃大厂转正，薪资翻倍入职字节",
      "url": "https://juejin.cn/post/7565176027909095470",
      "pubDate": "Mon, 27 Oct 2025 03:09:57 GMT",
      "description": "大家好，我是老A\n收藏夹式努力」。水文看不上，只想让大佬推荐技术宝典，一旦拿到手，焦虑感削弱，宝典就在收藏夹里吃灰，下了班照样峡谷开黑。当你想督促他深入研究时，他又会用「他是大佬，我不是，我做不到」来给自己设限，最终陷入「持续焦虑，持续躺平」的恶性循环。\n这种惰性，是人之常情。但人和人之间的差距，就在于如何对抗它。这让我想起了我去年带过的一个外包兄弟，小汪。坦白说，他刚来的时候，也和这位粉丝一样，技术普通，满脸焦虑，总觉得自己不行。\n但他最终，靠自己的努力，挣脱了这个循环。他没有转正，却在一年后，薪资翻倍进了字节。\n今天，我就把小汪的这段真实经历，以及我当时给他设计的那份「镀金计划」，毫无保留地分享出来。希望能为所有困在原地的兄弟，提供一条走得通的路。\n第一幕：一个困在围城的年轻人\n小汪是2023年6月份进组的，主要跟我做CRM的售卖系统，给我的第一印象是这小伙子阳光开朗，踏实肯干，不懒惰，很勤劳，基本每天都是第一个到公司（当然不是说第一个到公司就好，主要是从这点看出他很勤劳）。\n小汪的技术基础还行，大概半个多月就熟悉了公司的技术基础设施和基础业务，之后就开始跟着我做项目。\n他的成长速度真的很快，每天都会追着我问各种业务问题，应用问题还有代码问题，每次CR也都主动找我交流，能看的出来，他是真的很想进步，所以我也是倾尽所有的去教他带他。前半年，他工作的热情高涨，每天都像个小太阳一样，正能量满满，积极乐观的工作态度感染着周围的同学。\n但是半年后，明显感觉到这个小太阳能量不足了，脸上的笑容也越来越少，察觉到这个变化，我赶紧跟他进行了一次one one交流，让我终于知道了原因所在。\n小汪表示他觉得自己就是个二等公民，作为外包，他感受到了诸多不便，再努力都没用。\n不便一：各种权限申请搞疯掉\n小到一篇文档、一个钉钉名片、一个项目环境吧器，大到一个代码库、应用、开关、配置他通通都要经过4层以上的审批，给他的工作带来了极大的不便，过程中也倍受冷眼，比如跟某些大厂骄子申请权限，已读不回，钉了也不回的例子太多，其中的心酸只有他自己能懂。\n不便二：外包身份让他无法接触到核心\n虽然我带着他做项目，能教的都在教他，业务也都给他讲的明明白白，但是从不会让他接触到项目最核心的技术部分，也不会把核心开发部分交给他做（这个我要喊一句冤枉，不是不交给小汪做，是不能，我们有严格的要求核心研发必须正式员工来做，毕竟背锅也是我们自己来，所以自己做也比较放心，但是每次的CR我都会叫上小汪，让他知道这个需求的核心部分是如何实现的）。\n不便三：所有的需求都不会让他独立完成，都需要我出技术方案，他去执行\n小汪觉得这样很不利于他的成长，就像离不开鸡妈妈的小鸡（这里批评一下，这个比喻太不恰当了，我不是鸡妈妈😂）。后面这里我改为了他出方案，我来把关评审。\n不便四：所有的核心技术分享都接触不到\n小汪说他想成长，但是每次部门的核心技术分享都不会邀请他，他也不知道有哪些技术分享，这让他更加难受，想成长却没有门（这个我后面反思了，因为我们的技术分享基本都在晚上8点以后，外包同学基本6点多就下班了，所以之前我一直没好意思留下小汪，毕竟让人加班等到8点不太优雅，那次one one谈话后我每次分享都会提前告诉他）\n最后小汪终于道出了压在心底的话：他拼命工作、拼命学习，就是为了撕掉“二等公民”的标签，成为一个真正的“自己人”。但他抬头四顾，满眼都是绝望：“A哥，我来了一年多了，一个转正的都没见过。这条路，真的走得通吗？”\n第二幕：“B面”点化——“你的目标，从一开始就错了”\n听了他的话，我沉默了足足有半分钟。我不是在想怎么安慰他，我是在想，这盆冷水，到底该怎么泼下去，才不至于浇灭他眼里最后的光。\n所以我直接告诉他了外包转正的三个“残酷真相”：\n“HC（Headcount）隔离墙”：首先外包在哪个公司都算是一种技术资源，哪里需要去哪里。其招聘成本和正式员工不在一个等级，一个部门每年的正式员工HC是很珍贵的，基本一年1-2个，所以老板和HR都想把这个名额给到一个尽可能优秀的人。那么老板如何判断一个候选人是否优秀？第一就要看学历和工作经历，基本95%的外包同学都倒在这一关了。而一个外包HC就宽松多了，老板向部门申请预算也会容易的多，所以体现在面试上也容易很多。这就是为什么外包在老板这关就很难转正的原因。\n“招聘标准双轨制”：坦诚地说，社招一个P6的门槛，和外包转正一个P6的门槛，是完全不同的。我们社招的时候招一个P6的标准：985/211、有大厂经历、能独立完成中型项目、对自己做过的项目完全掌握这就行了。但是如果是外包转正一个P6：那你得有极其耀眼的项目经历或者做出过什么大贡献，比如挽回了1000万资损这种。但是这两个条件对于外包同学来说，难于上青天。。。这本身就是不公平的，却是赤裸裸的现实。\n“价值归属的原罪”：外包同学是不会自己负责一块独立的业务的，所以他在项目里做的所有业绩，在汇报时天然会归功于他的直属正式员工Leader。\n最后，我看着他的眼睛，一字一句地跟他说：“小汪，记住，从今天起，别再把转正当成你唯一的目标了。那是一条官方留给你，但几乎锁死的路。你的真正出路，是把在这里的每一天，都当成一场偷师学艺。你的目标，不是留下，而是镀金后，去一片更广阔的天空！”\n第三幕：镀金！从CRUD Boy到“准架构师”的技术蜕变\n1. 镀金第一步：“偷”文档，找到“战场”\n老A点化：我告诉小汪，你要学会“偷师”，去lark上把我们CRM系统所有的故障复盘文档，全都找出来读一遍。再去看架构组的周会纪要，看看那些P8、P9们，到底在为什么问题而头疼。同时多交好一些正式员工，作为资源人脉，一旦有HC可以做内推。\n发现“战场”： 小汪花了一周的下班时间，真的找到了一个有价值的痛点——一个半年前的P3故障复盘文档。这个故障始于CRM系统一个用于“同步客户签约状态”的核心接口，由于需要依次调用“会员中心”、“订购中心”、“风控中心”、“合同中心”四个下游服务，这几个系统都是有20年以上的历史的老系统，整个链路过长，在大促高并发下，TP99延迟飙升到5秒以上，导致整个签约流程的体验很差，经常出现签约异常情况。这个问题，因为“历史悠久、无人敢动”，至今只是做了限流（令牌桶），也提出了渐进式优化的方案，但是苦于业务排期压力，一直没有排上日程。\n老A点评：“镀金”的第一心法，找到那个所有人都知道痛，但没人敢治的“病灶”。这，就是你的战场。\n2. 镀金第二步：“偷”代码，找到“武器”\n小汪找到了“战场”，但却不知道该怎么解决。他能想到的，还是优化SQL、加缓存这些常规操作。\n老A点化：我直接把公司内另一个核心交易网关的代码读权限，给他临时申请了一天。然后告诉他：“别看那些修修补补的代码。去看看我们最新一代的交易应用代码，看看他们是如何编排和调度多个下游微服务的。偷师他们的设计思想。”\n“偷”到“圣经”：小汪在这份新代码里，第一次看到了一个完全不同的世界——基于CompletableFuture和ThreadPoolExecutor构建的、优雅的异步化、非阻塞的编排方案。他这才明白，高手们早就不用同步调用链这种办法了。\n3. 镀金第三步：从“看懂”到“精通”的灵魂拷问\n小汪看了一天的交易代码，然后兴奋地跑来找我，说他准备用CompletableFuture.allOf()来并行化那三个RPC调用。但他还没说完，我就提出了三个“B面”灵魂拷问，直接把他问住了：\n第一问：你打算用什么线程池来跑这些异步任务？\n小汪脱口而出：“就用CompletableFuture默认的就行吧？”\n我告诉他，这就是新手和老兵的第一个分水岭。默认的ForkJoinPool.commonPool()，就像一个顶级餐厅里那几个最牛的、做菜最快的大厨，它是为计算密集型任务设计的。\n而你的RPC调用，是IO密集型任务，就像是去等一份永远不知道何时能送达的外卖。如果你让大厨去等外卖，整个厨房很快就会瘫痪。\n正确的做法，是为这些IO任务，单独建立一个“服务员”线程池，让他们去等，别占用我们宝贵的大厨资源。\n// 老A的B面架构第一课：为IO密集型任务自定义线程池\nprivate final ThreadPoolExecutor syncExecutor = new ThreadPoolExecutor(\n    20, // 核心线程数，根据QPS和下游延迟估算\n    200, // 最大线程数，应对突发流量\n    60L, TimeUnit.SECONDS, // 空闲线程存活时间\n    new LinkedBlockingQueue<>(1000) // 队列大小，防止OOM\n);\n\n第二问：三个RPC调用，真的可以完全并行吗？\n我让他把旧代码贴出来，又问了他第二个问题：“你仔细看，这三个RPC调用，真的可以完全并行吗？” 小汪看着旧代码里那句orderClient.getLastOrder(info.getOrderId())，沉默了。\n他这才发现，获取“订单信息”，依赖于先获取“会员信息”的结果。\n我告诉他，allOf是万马奔腾，适用于没有依赖关系的并行任务。而这种需要“第一棒跑完，第二棒才能接力”的场景，你需要的是thenCompose<。这，是第二个分水岭。\n// 老A的B面架构第二课：用thenCompose处理依赖性的异步任务\nCompletableFuture<UserInfo> futureInfo = CompletableFuture.supplyAsync(...);\nCompletableFuture<OrderInfo> futureOrder = futureInfo.thenCompose(info -> \n    CompletableFuture.supplyAsync(() -> orderClient.getLastOrder(info.getOrderId()), syncExecutor)\n);\n\n第三问：你准备用thenAccept还是thenAcceptAsync来更新数据库？\n最后，我问了他第三个问题：“当所有结果都计算完，你准备用thenAccept还是thenAcceptAsync来更新数据库？” 小汪一脸茫然。\n我给他讲了一个真实的“B面”血泪史：曾经一个团队，因为在回调里使用了同步的thenAccept，而回调方法里又有一个微小的锁竞争，导致在高并发下，整个异步线程池被“反向”阻塞，引发了P2故障。\n这，是第三个分水岭—— 永远要假设你的回调逻辑也可能阻塞，用thenAcceptAsync把它也扔进线程池里去执行，做到“绝对隔离”。\n4. 终极镀金：用“A面”武器，重构“B面”屎山\n在我问出这三个问题，并把自定义线程池和ThenCompose这两个武器的核心代码画给他看之后，小汪说他要回去思考下。\n我知道，他已经悟了，聪明的小汪～\n又过了大概一周后，小汪发来了一个重构方案评审会邀，在会上他向我展示了他利用下班和周末的时间，写出的下面这份堪称“教科书级”的重构方案。\n超时控制（orTimeout）、基于指数退避的重试机制、以及完善的异常处理。\n他不再是简单地模仿，而是真正理解了系统痛点背后的“B面”权衡。\n我很惊讶于小汪的执行力，可以这么快就给出这样比较完整的方案。我对整体的重构方案进行了严格的技术把关和评估，最终评审通过，决定采用小A的这套方案，并通知小A配合测试同学给出压测方案和报告。\n团队双周技术分享会上，小汪主讲了这个重构方案，并给出了详尽的压测报告（P99延迟从5秒降到150ms，接口吞吐量提升300%），整个过程技惊四座。那一刻，再也没有人把他当外包了。\n@Service\npublic class UserSyncServiceV2 {\n    // 老A的B面架构第一课：为IO密集型任务自定义“服务员”线程池\n    private final ThreadPoolExecutor syncExecutor = new ThreadPoolExecutor(\n            20, \n            200, \n            60L,\n            TimeUnit.SECONDS, \n            new LinkedBlockingQueue<>(1000)\n    );\n    \n    // ... 注入各个Client ...\n    \n    public CompletableFuture<Boolean> syncStatusAsync(Long customerId) {\n        // 1. 并行获取无依赖的用户信息和风控结果\n        CompletableFuture<UserInfo> futureInfo = CompletableFuture.supplyAsync(\n                () -> userClient.getUserInfo(customerId), \n                syncExecutor\n        );\n        \n        CompletableFuture<RiskResult> futureRisk = CompletableFuture.supplyAsync(\n                () -> riskClient.checkRisk(customerId), \n                syncExecutor\n        );\n        \n        // 2. 老A的B面架构第二课：用thenCompose处理依赖性的异步任务（订单依赖用户信息）\n        CompletableFuture<OrderInfo> futureOrder = futureInfo.thenCompose(info -> {\n            if (info == null || info.getOrderId() == null) {\n                // 如果前序结果为空，优雅地返回一个空的Future\n                return CompletableFuture.completedFuture(null);\n            }\n            return CompletableFuture.supplyAsync(\n                    () -> orderClient.getLastOrder(info.getOrderId()), \n                    syncExecutor\n            );\n        });\n        \n        // 3. 老A的B面架构第三课，组合所有结果，并用thenApplyAsync进行最终的数据库操作\n        return CompletableFuture.allOf(futureOrder, futureRisk)\n                .thenApplyAsync(v -> {\n                    // ...从各个Future中join()结果，并进行组合...\n                    // ...验证数据完整性...\n                    \n                    // 更新数据库\n                    updateDatabase(syncResult);\n                    \n                    log.info(\"用户状态同步成功, customerId: {}\", customerId);\n                    return true;\n                }, syncExecutor)\n                .exceptionally(e -> {\n                    log.error(\"异步同步失败, customerId: {}\", customerId, e);\n                    return false;\n                });\n    }\n    \n    // ... updateDatabase()等私有方法 ...\n}\n\n老A说：从毕业作品到“生产级”的最后三公里\n兄弟们，小汪的这份代码，已经是一个极其优秀的技术验证原型。但要把它真正投入生产，我们还需要打磨三个“B面”细节：\n线程池的哨兵： 必须为这个线程池配置合理的拒绝策略，并接入相关监控平台（如Sunfire）进行监控，防止在高并发下被打爆。\n异步安全保障： exceptionally里的简单日志还不够。生产级代码需要集成Resilience4j这样的熔断器和重试框架，防止下游服务的抖动引发雪崩。\n数据的安全锁： 异步化后，如何保证数据一致性？我们需要引入Saga或TCC等分布式事务方案，来确保整个流程的原子性。\n这最后三公里，才能区分出你是高级工程师还是架构师\n第四幕：一年之后——“他放弃了转正的想法，选择了字节”\n就这样，小汪按照我的镀金计划不断的“偷师取经，稳步成长”，我能明显感觉到他在技术、视野和自信心上发生了脱胎换骨的变化。今年年初，我们的一个正式HC恰好空出，老板也确实在考虑他。但与此同时，通过之前积攒来的人脉，他也拿到了一个字节的面试机会。结果也在我的意料之中，他顺利通过了面试，薪资直接翻倍。他最终礼貌地“放弃”了在内部等待那个不确定的转正机会，飞到了另一片天空。\n感言\n我至今都记得小汪拿到Offer后请我吃饭时说的话：“A哥，谢谢你，没有你就没有我的今天。谢谢你让我找到成长的最优路径，谢谢你掏心窝子对我说的那些话，谢谢你对我的倾囊相授，谢谢你让我明白成长的意义所在，谢谢你让我知道我可以，我能行！”\n老A说：其实一个人的价值，不应该由别人给你打上的身份标签来定义。我们可能无法选择起点，但可以通过正确的战略和努力，选择自己的终点。\n老A时间\n感谢各位兄弟的阅读。\n我是老A，一个只想跟你说点B面真话的师兄。如果这篇文章让你有了一点点启发，那就是对我最大的肯定。\n为了感谢大家的支持，我把这两年在一线大厂面试和带团队中，沉淀下来的所有上不了台面的私房笔记，整理成了一份《程序员B面生存手册》。\n里面没有市面上千篇一律的八股文，只有一些极其管用的“潜规则”和“避坑指南”，希望能帮你少走一些弯路。\n关注我的同名公众号【大厂码农老A】，在后台回复“B面”，就能免费获取。\n回复“简历”获取《简历优化手册》\n回复“arthas”获取史上最全的《大厂arthas实战手册》\n回复“指导”获取《大厂外包镀金手册》\n最后，如果觉得内容还行，也希望能点个赞、点个在看，让更多需要它的兄弟看到。\n我们一起，在技术的路上结伴“陪跑”。",
      "hotIndex": 5,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7565204846044102671",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "为什么 Electron 项目推荐使用 Monorepo 架构 🚀🚀🚀",
      "url": "https://juejin.cn/post/7565204846044102671",
      "pubDate": "Mon, 27 Oct 2025 01:22:29 GMT",
      "description": "最近在使用 NestJs 和 NextJs 在做一个协同文档 DocFlow，如果感兴趣，欢迎 star，有任何疑问，欢迎加我微信进行咨询 yunmz777\n在现代前端开发中，Monorepo（单一代码仓库）架构已经成为大型项目的首选方案。对于Electron应用开发而言，Monorepo架构更是带来了诸多优势。本文将以一个实际的Electron项目为例，深入探讨为什么Electron项目强烈推荐使用Monorepo架构，以及它如何解决传统多仓库架构的痛点。\n什么是Monorepo\nMonorepo是一种软件开发策略，它将多个相关的项目或包存储在同一个代码仓库中。与传统的多仓库（Multi-repo）架构不同，Monorepo允许开发团队在单一代码库中管理多个相互依赖的模块。\nElectron项目的复杂性分析\nElectron应用通常包含以下核心组件：\n主进程（Main Process）：负责创建和管理应用窗口\n渲染进程（Renderer Process）：运行前端UI代码\n预加载脚本（Preload Scripts）：安全地桥接主进程和渲染进程\n共享代码库：业务逻辑、工具函数、类型定义等\n构建配置：Webpack、Vite等构建工具配置\n打包配置：Electron Builder等打包工具配置\n这种多层次的架构使得代码组织变得复杂，传统的多仓库架构往往无法很好地处理这些组件之间的依赖关系。\n实际项目结构深度解析\n让我们以您的项目为例，深入分析Monorepo架构的实际应用：\n项目整体架构\nelectron-app/\n├── apps/                          # 应用层\n│   ├── electron-app/             # Electron主应用\n│   │   ├── src/\n│   │   │   ├── main/             # 主进程代码\n│   │   │   └── preload/          # 预加载脚本\n│   │   ├── build/                # 构建配置\n│   │   └── package.json          # 应用依赖\n│   └── react-app/                # React前端应用\n│       ├── src/\n│       │   ├── components/       # React组件\n│       │   └── page/             # 页面组件\n│       └── package.json          # 前端依赖\n├── packages/                      # 共享包层\n│   ├── electron-core/            # 核心业务逻辑\n│   │   ├── src/\n│   │   │   ├── base-app.ts       # 基础应用类\n│   │   │   ├── app-config.ts     # 应用配置\n│   │   │   ├── menu-config.ts    # 菜单配置\n│   │   │   └── ffmpeg-service.ts # FFmpeg服务\n│   │   └── package.json\n│   ├── electron-ipc/             # IPC通信封装\n│   │   ├── src/\n│   │   │   ├── ipc-handler.ts    # IPC处理器\n│   │   │   ├── ipc-channels.ts   # IPC通道定义\n│   │   │   └── ipc-config.ts     # IPC配置\n│   │   └── package.json\n│   └── electron-window/          # 窗口管理\n│       ├── src/\n│       │   ├── window-manager.ts # 窗口管理器\n│       │   └── window-factory.ts # 窗口工厂\n│       └── package.json\n├── scripts/                       # 构建脚本\n├── package.json                   # 根配置\n├── pnpm-workspace.yaml           # Workspace配置\n├── turbo.json                    # Turbo构建配置\n└── tsconfig.json                 # TypeScript配置\n\n核心配置文件分析\n1. pnpm-workspace.yaml - 工作空间配置\npackages:\n  - 'apps/*'\n  - 'packages/electron-*'\n\n这个配置定义了工作空间的范围，告诉pnpm哪些目录包含包。这种配置的优势：\n统一依赖管理：所有包共享同一个node_modules\n版本一致性：确保所有包使用相同版本的依赖\n安装效率：避免重复安装相同的依赖\n2. turbo.json - 构建管道配置\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"globalDependencies\": [\"/.env.*local\"],\n  \"tasks\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\"dist/\", \"out/\", \"build/\", \".next/\"]\n    },\n    \"dev\": {\n      \"cache\": false,\n      \"persistent\": true\n    },\n    \"lint\": {\n      \"dependsOn\": []\n    },\n    \"typecheck\": {\n      \"dependsOn\": [\"^build\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"^build\"]\n    },\n    \"clean\": {\n      \"cache\": false\n    },\n    \"format\": {\n      \"cache\": false\n    }\n  }\n}\n\n这个配置定义了构建管道，实现了：\n依赖关系管理：dependsOn: [\"^build\"]确保依赖包先构建\n增量构建：只构建发生变化的包\n并行执行：多个独立任务可以并行运行\n缓存机制：避免重复构建\n3. 根package.json - 统一脚本管理\n{\n  \"scripts\": {\n    \"build\": \"turbo run build\",\n    \"dev\": \"turbo run dev\",\n    \"lint\": \"turbo run lint -- --fix\",\n    \"typecheck\": \"turbo run typecheck\",\n    \"electron:dev\": \"turbo run dev --filter=@monorepo/react-app && turbo run dev --filter=my-electron-app\",\n    \"electron:build\": \"turbo run build --filter=@monorepo/react-app && turbo run build --filter=my-electron-app\"\n  }\n}\n\nMonorepo架构的六大核心优势\n1. 统一的依赖管理\n传统多仓库架构的问题：\n每个子项目都需要独立管理依赖\n容易出现版本不一致的问题\n重复安装相同的依赖，浪费磁盘空间\nMonorepo解决方案：\n在您的项目中，所有包都使用workspace:*协议引用内部依赖：\n// apps/electron-app/package.json\n{\n  \"dependencies\": {\n    \"@monorepo/electron-core\": \"workspace:*\",\n    \"@monorepo/electron-window\": \"workspace:*\",\n    \"@monorepo/electron-ipc\": \"workspace:*\"\n  }\n}\n\n这种配置的优势：\n版本一致性：所有包使用相同版本的内部依赖\n实时更新：修改共享包后，依赖包立即获得更新\n避免重复：pnpm的符号链接机制避免重复安装\n2. 代码共享与复用\n实际案例分析：\nBaseApp基类的共享\n// packages/electron-core/src/base-app.ts\nexport abstract class BaseApp {\n  protected config: AppConfig;\n\n  constructor(config: AppConfig) {\n    this.config = config;\n  }\n\n  abstract initialize(): void;\n\n  protected setupAppEvents(): void {\n    app.on('activate', () => {\n      if (this.shouldCreateWindow()) {\n        this.createWindow();\n      }\n    });\n\n    app.on('window-all-closed', () => {\n      if (process.platform !== 'darwin') {\n        app.quit();\n      }\n    });\n  }\n\n  protected abstract shouldCreateWindow(): boolean;\n  protected abstract createWindow(): void;\n}\n\n这个基类被多个应用共享，提供了：\n统一的生命周期管理：所有Electron应用都遵循相同的生命周期\n代码复用：避免在每个应用中重复实现相同的逻辑\n类型安全：通过抽象类确保所有子类实现必要的方法\nIPC通信的封装\n// packages/electron-ipc/src/ipc-handler.ts\nexport class ElectronIpcHandler implements IpcHandler {\n  setupHandlers(): void {\n    // Basic IPC handlers\n    ipcMain.on('ping', () => console.log('pong'));\n\n    // App info handlers\n    ipcMain.handle('get-app-version', () => {\n      return process.env.npm_package_version || '1.0.0';\n    });\n\n    ipcMain.handle('get-platform', () => {\n      return process.platform;\n    });\n\n    // System info handlers\n    ipcMain.handle('get-system-info', () => {\n      return {\n        platform: process.platform,\n        arch: process.arch,\n        version: process.version,\n        nodeVersion: process.versions.node,\n        electronVersion: process.versions.electron,\n      };\n    });\n  }\n}\n\n这个IPC处理器提供了：\n统一的通信接口：所有IPC通信都通过标准化的接口\n类型安全：通过TypeScript接口确保通信的类型安全\n可扩展性：易于添加新的IPC处理器\n3. 原子性提交\n传统多仓库架构的问题：\n跨仓库的修改需要分别提交\n容易出现不一致的状态\n难以追踪相关的修改\nMonorepo解决方案：\n在您的项目中，一次提交可以同时修改多个相关文件：\n# 一次提交同时修改多个包\ngit add packages/electron-core/src/base-app.ts\ngit add packages/electron-ipc/src/ipc-handler.ts\ngit add apps/electron-app/src/main/index.ts\ngit commit -m \"feat: 重构应用基类和IPC处理器\"\n\n这种提交方式的优势：\n原子性：相关修改作为一个整体提交\n一致性：确保所有相关文件的状态一致\n可追溯性：通过git历史可以追踪完整的修改过程\n4. 统一的构建和测试\n实际构建流程分析：\nTurbo构建管道\n{\n  \"tasks\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\"dist/\", \"out/\", \"build/\", \".next/\"]\n    }\n  }\n}\n\n这个配置实现了：\n依赖构建：^build确保依赖包先构建\n增量构建：只构建发生变化的包\n并行构建：多个独立包可以并行构建\n实际构建命令\n# 构建所有包\npnpm run build\n\n# 只构建Electron应用\npnpm run electron:build\n\n# 只构建React应用\npnpm run react:build\n\n5. 更好的开发体验\n一站式开发环境：\n# 启动整个开发环境\npnpm run dev\n\n# 启动Electron开发环境\npnpm run electron:dev\n\n这种开发体验的优势：\n单一命令启动：一个命令启动整个开发环境\n热重载：修改代码后自动重新加载\n统一调试：可以在同一个IDE中调试所有代码\n6. 类型安全\nTypeScript项目引用：\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"declaration\": true,\n    \"declarationMap\": true\n  },\n  \"references\": [\n    { \"path\": \"./packages/electron-core\" },\n    { \"path\": \"./packages/electron-ipc\" },\n    { \"path\": \"./packages/electron-window\" },\n    { \"path\": \"./apps/electron-app\" },\n    { \"path\": \"./apps/react-app\" }\n  ]\n}\n\n这种配置实现了：\n增量编译：只编译发生变化的文件\n类型检查：确保所有包的类型定义一致\n智能提示：IDE可以提供完整的类型提示\n实际开发流程分析\n1. 新功能开发流程\n假设要添加一个新的IPC处理器：\n在共享包中定义接口：\n// packages/electron-ipc/src/ipc-channels.ts\nexport const IPC_CHANNELS = {\n  // ... 现有通道\n  NEW_FEATURE: 'new-feature',\n} as const;\n\n实现处理器：\n// packages/electron-ipc/src/ipc-handler.ts\nipcMain.handle(IPC_CHANNELS.NEW_FEATURE, () => {\n  // 实现逻辑\n});\n\n在应用中注册：\n// apps/electron-app/src/main/index.ts\nconst ipcConfig = new IpcConfig();\nipcConfig.setupHandlers();\n\n在前端中使用：\n// apps/react-app/src/components/SomeComponent.tsx\nconst result = await window.electronAPI.invoke('new-feature');\n\n2. 依赖更新流程\n当需要更新共享包时：\n修改共享包：\n// packages/electron-core/src/base-app.ts\n// 添加新功能\n\n自动更新依赖：\n由于使用workspace:*，所有依赖包自动获得更新\n类型检查：\npnpm run typecheck\n\n构建测试：\npnpm run build\n\n性能优化分析\n1. 构建性能\nTurbo缓存机制：\n构建结果缓存到.turbo目录\n只有发生变化的包才会重新构建\n并行构建多个独立包\n实际性能提升：\n首次构建：~30秒\n增量构建：~5秒\n缓存命中：~1秒\n2. 开发性能\n热重载优化：\n只重新加载发生变化的模块\n保持应用状态\n快速反馈循环\n3. 安装性能\npnpm优势：\n符号链接避免重复安装\n全局缓存减少网络请求\n并行安装提高速度\n最佳实践总结\n1. 包划分原则\n按功能模块划分：\nelectron-core：核心业务逻辑\nelectron-ipc：IPC通信\nelectron-window：窗口管理\n避免过度拆分：\n不要为了拆分而拆分\n保持包的职责单一\n考虑包的维护成本\n2. 依赖管理\n使用workspace协议：\n{\n  \"dependencies\": {\n    \"@monorepo/electron-core\": \"workspace:*\"\n  }\n}\n\n避免循环依赖：\n使用依赖图分析工具\n定期检查依赖关系\n重构消除循环依赖\n3. 构建优化\n利用Turbo缓存：\n合理设置outputs目录\n使用dependsOn管理依赖\n避免不必要的重新构建\n4. 代码规范\n统一配置：\nESLint配置统一管理\nPrettier格式化统一\nTypeScript配置统一\n迁移策略\n1. 评估现有项目\n分析您当前的项目结构：\n识别可复用的代码\n分析依赖关系\n确定迁移优先级\n2. 选择工具链\n基于您的项目，推荐的工具链：\n包管理器：pnpm（已使用）\n构建工具：Turbo（已使用）\n类型检查：TypeScript（已使用）\n3. 逐步迁移\n第一阶段：迁移核心包\n将共享代码提取到packages目录\n设置workspace配置\n更新依赖引用\n第二阶段：迁移应用\n重构应用代码使用共享包\n更新构建配置\n测试功能完整性\n第三阶段：优化配置\n优化Turbo配置\n设置CI/CD流程\n性能调优\n总结\nMonorepo架构为Electron项目带来了显著优势：统一的依赖管理通过pnpm workspace实现版本一致性，代码共享与复用让BaseApp、IPC处理器等核心组件被多个应用共享，原子性提交确保相关修改作为一个整体提交，统一的构建和测试通过Turbo实现增量构建和并行执行，更好的开发体验提供一站式开发环境，类型安全通过TypeScript项目引用实现完整的类型检查。对于复杂的Electron应用而言，Monorepo架构不仅是一个推荐的选择，更是一个必要的架构决策，它能够显著提高开发效率和代码质量，为项目的长期发展奠定坚实的基础。",
      "hotIndex": 6,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7564695725026263059",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "今年各大厂都在跟进的智能眼镜是什么？为什么它突然就成为热点之一？它是否是机会？",
      "url": "https://juejin.cn/post/7564695725026263059",
      "pubDate": "Sun, 26 Oct 2025 23:38:44 GMT",
      "description": "相信今年大家或多或少听过各大厂都在进军智能眼镜领域，比如小米、Oppo、阿里、华为等都已经发布了自己的智能眼镜产品，另外诸如字节跳动等企业也都在跟进研发中，那为什么这两年眼镜这个早已被遗忘的穿戴产品，会又再一次被重视起来呢？要知道多年前的谷歌眼镜可是已经“折戟沉沙”过。\n\n答案其实很简单：\n1、因为如今的 AI 成熟度很高，给眼镜带来了更多可能，在导航、聊天、智能识别、回答问题、支付等领域更加实用\n2、AR 场景的支持更加成熟\n3、国外已经有成熟的已验证案例\n是的，也是对于国内来说智能眼镜场景可能还很陌生，但是在国外智能眼镜的市场在近两年已经得到了一定程度的验证，证明了这个方向是可行，且市场发展前景非常不错。\n比如近日亚马逊就发布了它们内部员工使用的智能眼镜，在工作场景可以看出来是有相当不错的效率提升：\n\n\n那么大家觉得目前全球智能眼镜的霸主是谁？是苹果还是谷歌？答案都不是，可能出乎大多数人意料，目前智能眼镜和 AR 领域，占据绝对优势地位的是 Meta ：\n\n在今年 IDC公布 Q1 全球 XR 市场份额排名，Meta 稳居第一，而根据 CounterPoint Research 9 月 12 日发布的报告，2025 年第二季度，Meta 以 71% 的市场份额继续领跑全球扩展现实（XR）头显市场。\n\n而实际在销量上，Meta 的部分产品销量为：\nRay-Ban Meta 智能眼镜在 2025年 2 月就已突破 200 万台销量大关，预计今年最高可以达到 400 - 500 万副\nQuest 3头显：在2024年6月的销量突破了100万台\n另外 IDC 还针对智能眼镜未来市场也做了预测，比如 2025 年全球智能眼镜市场出货量，预计达到 1,451.8 万台，同比增长 42.5% ，相对应的 AR / VR 设备出货量预计 569.0 万台。\n是不是很意外，Meta 目前在这个领域是遥遥领先，而我们为什么对 Meta 在这个领域陌生，主要是因为 Meta 没对国内开放，就算你买了也会锁区。\n而从数据上可以看出来，目前这个领域的前景还是很可观，所以国内厂商都开始发力这个领域无可厚非，另外因为 AI 存在“区域性保护”的问题，所以也注定了国外眼镜产品在国内没有优势，另外可能有个大家都不是很熟悉的品牌：雷鸟，作为 TCL 的子品牌，在眼镜这个领域其实也是深耕许久，特别是在“致敬” Meta 的道路上发展许久 ，也算是国内智能眼镜的第一梯队：\n\n那么除了 AI，还有什么让智能眼镜迅速发展吗？那肯定是智能眼镜上的显示渲染方案 ，对比起当年的谷歌眼镜，现在的智能眼镜方案更加成熟多样，眼镜主要可以根据其核心的光学方案分为两大阵营：“光波导 (Waveguide) ” 和 “鸟浴式 (Birdbath) ” ：\n\n第一种方案是光波导方案，如上效果所示，简单来说，光波导技术的核心物理原理是全内反射，当光线从一个折射率较高的介质（如玻璃）射向一个折射率较低的介质（如空气）时，如果入射角大于某个临界角，光线将不会折射出去，而是被完全反射回高折射率介质内部，通过这种方式：\n光线可以在一片薄薄的镜片内部像在光纤中一样被“引导”和传播。\n而在这个基础上又分为几何光波导和衍射式光波导，简单区别就是：\n几何光波导是在玻璃基底内部嵌入了一系列微型、有特定角度的半透半反镜面阵列\n衍射式光波导是利用纳米级的光栅结构来耦合和引导光线，而光栅可以是蚀刻或压印在镜片表面的浮雕\n看不明白无所谓，只需要知道，这种场景下的眼镜 AR 类似 HUD ，而因为是处理在镜片上实现，所以镜片基本是不可更换，也就是镜片如果不支持定制处方镜片，那么对于近视人群就非常不友好，当然就算可以定制，更换成本也不低：\n\n当然好处也很明显，这类眼镜和普通眼镜非常近似，具有高透明度、轻薄化和接近普通眼镜的外观，适合全天候佩戴，不过另外此类方案的镜片，在一定角度一般也可以看到屏幕上的反射区域（腐刻区域），显示内容也有单眼或双眼的不同配置，而且也有不同的光引擎技术（LCoS 、MicroLED、Micro-OLED）选择，比如：\n\n品牌主力产品光引擎技术显示配置外部可见性\n\nMetaRay-Ban DisplayLCoS (硅基液晶)单镜片 (右眼彩色显示)完全不可见，隐私性极高\nTCL (雷鸟)RayNeo X2MicroLED (全彩)双镜片 (双目彩色显示)镜片透明，但显示区域的光栅结构在特定角度下可能被观察到\nRokidRokid GlassesMicroLED (单色)双镜片 (双目单色显示)镜片透明，显示区域可见\nOppoAir Glass / Air Glass 3MicroLED (单色/彩色)单镜片 (Air Glass) / 双镜片 (Air Glass 3)镜片透明\n夸克 (阿里)Quark AI Glasses (AI+AR版)MicroLED双目光波导镜片透明\n\n第二类方案“鸟浴式”光学方案 (Birdbath) 其实更类似“随身巨幕”的屏幕形态，这类眼镜的核心功能是媒体场景，通过牺牲一定的透光率（外观类似太阳镜）来换取巨大的视场角和出色的对比度：\n\n这是一种结构相对简单的光学系统，主要由两个核心元件组成，分为一个分光镜（半透半反的平面镜）和一个球面合束镜（曲面半透半反镜）：\n来自微型显示器的光线首先被分光镜反射，射向球面合束镜\n球面合束镜将图像放大并反射回分光镜\n这样光线可以穿过分光镜进入眼睛，而来自现实世界的光线则依次穿过球面合束镜和分光镜进入眼睛，从而实现图像叠加，具体的例子有：\n\n品牌主力产品光学方案光引擎技术外部可见性镜片更换/处方支持\n\nXREALAir 2 Pro / One Pro鸟浴式 (Birdbath)Micro-OLED镜片较暗，类似太阳镜，无法直接看到显示内容，但能看出设备在工作不可更换；通过磁吸处方镜片插片实现\nVitureLuma Pro / Luma XR鸟浴式 (Birdbath)Micro-OLED镜片较暗，类似太阳镜不可更换；支持屈光度调节或使用处方镜片插片\nTCL (雷鸟)RayNeo Air 3s鸟浴式 (Birdbath)Micro-OLED镜片较暗，类似太阳镜不可更换；通过处方镜片插片实现\nRokidMax2鸟浴式 (Birdbath)Micro-OLED镜片较暗，类似太阳镜不可更换；通过处方镜片插片实现\n\n这类智能眼镜与其说是眼镜，倒不如说是轻便式的穿戴屏幕，它其实更接近墨镜的场景，也不是特别适合日常外出作为常佩戴眼镜，但是有个好处就是相对还是比较轻便：\n\n之所以需要镜片较暗，主要是因为 Birdbath 的光效率极低，图像光线需要两次经过分光镜（一次反射，一次透射），导致巨大的光能损失，同时这类眼镜也是存在需要双镜片的情况，佩戴后从侧面看也会相对突出：\n\n实际上，针对更换处方镜片的场景，目前比较多的就是使用模块化插片，这也是目前最普遍的方法，一个独立的、包含用户处方镜片的次级镜框，通过磁力或物理卡扣固定在智能眼镜的内侧 ，比如 XREAL 这样的产品就基于这样的实现居多。\n总结一下，如果基于目前的主流实现，具体有：\nLCoS + 反射式光波导：为效率、透明度和低调外形进行了优化，过去情境式 HUD 的主流选择之一\nMicro-OLED + Birdbath：为视场角和对比度进行了优化，是在固定环境下进行沉浸式媒体消费的理想选择\nMicroLED + 衍射式光波导：为了实现真正的日光下可见 AR 的新兴架构，目前领域的主流选择之一\n\n最后其实还有一种虚拟视网膜显示（VRD）方案，只是目前的应用相对较少，比如来自 brilliant labs 的智能眼镜方案就有类似 Halo Display 的支持：\n\n简单来说，VRD（Virtual Retinal Display）是一种从根本上不同的“无屏幕”技术，它不产生任何中间的真实图像，而是使用一束低功率激光（彩色则使用红绿蓝三色激光），通过微型扫描振镜，将调制后的光束以光栅扫描的方式直接“画”在用户的视网膜上 ，通过逐个像素地调制激光强度，大脑便能感知到一幅完整的图像：\n\n当然，如果真要说显示效果，肯定还是目前的 XR 领域的头戴设备更好，比如 vision pro、Meta Quest 和刚刚发布的 Galaxy XR 肯定更好：\n\n\n\n总销量上依然是 Meta 占据优势。\n针对这类产品，它们支持在 AR 和 VR 直接切换，沉浸效果和交互效果更优质，例如下面这些是 Galaxy XR 的交互效果：\n\n\n\n但是对比眼镜场景这些头戴设备有几个直观问题：\n更贵\n更重\n不适合日常出门\n续航问题\n最核心就是日常带着一个这样的东西在路上走，其实有点羞耻了（部分人除外），如果在公共场景，这样的情况是不是会有些诡异：\n\n并且这个重量加续航，头戴设备也不适合长时间外出佩戴，所以更适合固定场景使用,而目前支持的场景也不够多，所以也没像手机一样普及。\n另外，在控制方面，智能眼镜主要依赖语音交互，有的是需要你抬手按下眼镜上的特定按键，而在这方面，为了解决语音交互在公共场所的尴尬问题，今年 Meta 也发布了一个其他控制途径：肌电手环 sEMG。\n通过佩戴一个手环，检测用户的手势信号（肌电信号），从而实现眼镜的功能控制，甚至实现聊天的文字输入（英语）：\n\nMeta 针对这个功能就开源过一个 emg2pose 项目， 这个项目的算法用了一个包含25,253个HDF5文件的大型数据集，文件记录了193 名参与者在 29 个不同阶段（如数数、抓握等）的手部动作，每个文件都包含时间对齐的、以2kHz频率采样的表面肌电图（sEMG）和通过运动捕捉系统记录的真实手部关节角度，sEMG数据从手腕设备上的16个电极通道采集，数据会被分割成窗口（例如，1秒的窗口包含2000个EMG样本）进行处理：\n\n可以看到，智能眼镜目前来说还是相对不错的赛道，如果硬要说有什么限制着智能眼镜的发展，那大概率还是电池续航和功耗，还有价格。\n目前对于续航方面，通用方案是提供外置磁吸式电池的支持。\n目前因为体积限制，智能眼镜的内置电池大多 200 毫安左右，并且由于功耗和散热问题，智能眼镜高度依赖 手机 App 的联网和后期处理能力，所以目前这个赛道的 App 还有个特点：基本都是纯原生开发。\n因为需要涉及蓝牙的交互（音乐、音效、语音交互、BLE）和 AI 模型等能力，手机平台比较强关联，所以导致目前几乎各大眼镜 App 都是纯原生开发，这也算是这个赛道的一个特色。\n那么，你觉得智能眼镜的未来如何？是否会是另外一个未来会被普及的穿戴设备？",
      "hotIndex": 7,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7565092711716847626",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "不当韭菜 ： 好像真有点效果 ，想藏起来自己用了",
      "url": "https://juejin.cn/post/7565092711716847626",
      "pubDate": "Sun, 26 Oct 2025 14:32:50 GMT",
      "description": "一. 前言\n前景提要 ： 从去年年底开始 ，就一直在完善一个股市辅助软件 ，用来收集股市里面我们关心的内容 ，作为操作的事实依据。\n从今年年中开始 ，就在逐步的借助它进行选股 。 （可能是错觉） ， 这两个月找到了一些感觉 ，虽然没办法做到很高的准确度 ，但是整体来说选的股票里面 超过半数 达到的预期。\nPS ：有可能是行情好了 ，哈哈哈哈哈哈哈哈哈哈哈\n工具的目的 ：\n辅助 ❗ ❗ 辅助  ❗ ❗ 辅助  ❗ ❗\n做决策的始终是人 ，这不是量化工具 ，只是一个简单的数据聚合工具罢了\n工作太忙没时间 复盘 ，交给它去做\n项目开源地址在文末\n二. 新增功能\n2.1 日志管理\n目的 ： 每天会查询最新的股票新闻 ，记录当天的股市信息 ，优势股票 ，用于后市的分析\n数据源 ： 月之暗面 /  智谱青言 / perplexity ， 我个人主要是用 perplexity 的 AI API ，没有的兄弟可以选择前两个\n\n\n2.2 板块监控\n目的 ： 板块轮动才是 A 股永恒的主题 ，该模块用来监控这段时间的优势板块 ，以及已经沉淀了一段时间的股票\n\n2.3 新闻列表\n目的 ： 新闻具有滞后性 ，买股要在关联消息出来之后 ，实际消息出来之前买。\n- 也就是说 ： 政府投入某个项目 ，可能1-2年之前就会放出消息 ，这个期间对应股票不会有太大变化\n- 但是 ： 作为散户 ，这种消息值得我们持续的关注 ，当发现消息开始变多的时候 ，可能就是介入的时间\n\n2.4 个股推荐\n目的 ：其实到了后面 ，真正胜率高的策略总是那几个 ，我这里就是为了抓这几个策略对应的股票\n\n\n\n2.5 日报管理（半成品）\n目的 ： 把上述功能里面一些核心的内容记录一下 ，发送到对应的邮箱里面\n\n\n\n三. 下一步计划\n3.1 AI Agent 内容分析\n主要原因在于股市的不确定性还是太高了 ，消息太多太多 ，时间跨度又大。\n计划 ：\n第一步 ： 基于历史消息 + 实时消息 ，转化为向量后 ，作为数据的知识库\n第二步 ： 基于 Crew AI 的开源多智能体框架 ，对各渠道信息进行收集\n第三步 ： 对符合策略的股票进行二次分析 ，排除掉高风险 ，低收益的股票 ，减少误判\n当前进度 10% ， 计划年底看能不能出来一个效果。\n四. 为什么我觉得有搞头了 ？\n因为确实还是抓到了几个大涨股 ，从一开始只有大涨后才知道 ，到现在重点关注池里面（基于策略，一般5-10个股） ，总会有1-2个股票能符合预期大涨。\n也就是从数学角度说 ，我每个股票投入一样的钱 ，如果其他的股票亏只亏1-2个点 ，凭借这1-2个大涨的，也许可以做到收支平衡。\n当然也只是想想啊 ，不确定是不是运气 ，还在跑数据\n感觉再细化策略 ，整合信息 ，胜率能进一步提高，只要股票池里面命中率能超过半数 ，我觉得就可以退休了。\n总结\n每篇都要提一下 :\n我始终不信任其他人的策略 ，包括 AI/大牛什么的 ， 完全照搬是肯定会有问题的，资金量，消息面都不一样。\n多学习 ，多思考 ，参考别人的交易方式 ，形成自己的交易模式才是这个软件的目的。\n鼓励大家从头去实现自己的软件 ，我的工具里面加入了很多私人的习惯 ，不建议直接用，至少要改一改。\n源码地址 ：\ngitee.com/antblack/an…\n💰💰💰最后 ，见此发财 ，大吉大利。💰💰💰\n最后的最后 ❤️❤️❤️👇👇👇\n👈  欢迎关注  ，超200篇优质文章，未来持续高质量输出 🎉🎉\n🔥🔥🔥 系列文章集合，高并发，源码应有尽有 👍👍 \n走过路过不要错过 ，知识无价还不收钱 ❗❗",
      "hotIndex": 8,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7564761412310401070",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "Canvas实现协同电影选座",
      "url": "https://juejin.cn/post/7564761412310401070",
      "pubDate": "Sun, 26 Oct 2025 11:40:09 GMT",
      "description": "技术栈\nReact + Canvas + Socket.IO + Express\n效果图\n\n架构设计\n┌─────────────────┐    WebSocket    ┌─────────────────┐\n│   React Client  │ ←──────────────→ │  Express Server │\n│                 │                 │                 │\n│ ┌─────────────┐ │                 │ ┌─────────────┐ │\n│ │   Canvas    │ │                 │ │  Socket.IO  │ │\n│ │  Renderer   │ │                 │ │   Handler   │ │\n│ └─────────────┘ │                 │ └─────────────┘ │\n│                 │                 │                 │\n│ ┌─────────────┐ │                 │ ┌─────────────┐ │\n│ │ Socket.IO   │ │                 │ │ Seat Data   │ │\n│ │   Client    │ │                 │ │  Manager    │ │\n│ └─────────────┘ │                 │ └─────────────┘ │\n└─────────────────┘                 └─────────────────┘\n\n核心功能实现\n1. Canvas渲染\n设备像素比适配\n现代设备的高分辨率屏幕（如Retina显示器）会导致Canvas绘制的图像显得模糊。我们通过适配设备像素比来解决这个问题：\nconst drawSeatMap = useCallback(() => {\n  if (!seatData || !canvasRef.current) return;\n\n  const canvas = canvasRef.current;\n  const ctx = canvas.getContext('2d');\n  \n  // 获取设备像素比\n  const dpr = window.devicePixelRatio || 1;\n  \n  // 获取Canvas的显示尺寸\n  const rect = canvas.getBoundingClientRect();\n  const displayWidth = rect.width;\n  const displayHeight = rect.height;\n  \n  // 设置Canvas的实际像素尺寸\n  canvas.width = displayWidth * dpr;\n  canvas.height = displayHeight * dpr;\n  \n  // 缩放绘图上下文以匹配设备像素比\n  ctx.scale(dpr, dpr);\n  \n  // 设置Canvas的CSS尺寸\n  canvas.style.width = displayWidth + 'px';\n  canvas.style.height = displayHeight + 'px';\n}, [seatData, hoveredSeat, userId]);\n\n这种处理方式确保了在各种设备上都能获得清晰的显示效果。\n座位布局\n采用了符合真实影院布局的设计：\n// 座位配置常量\nconst SEAT_SIZE = 30;        // 座位大小\nconst SEAT_SPACING = 35;     // 座位间距\nconst ROW_SPACING = 40;      // 行间距\nconst CANVAS_PADDING = 50;   // 画布边距\nconst AISLE_WIDTH = 20;      // 过道宽度\n\n// 绘制单个座位\nconst drawSeat = (ctx, row, seat, seatInfo, seatId) => {\n  // 计算座位位置，第6座后添加过道\n  const x = CANVAS_PADDING + seat * SEAT_SPACING + (seat >= 6 ? AISLE_WIDTH : 0);\n  const y = CANVAS_PADDING + 60 + row * ROW_SPACING;\n\n  // 根据座位状态确定颜色\n  let color = SEAT_COLORS.available;\n  if (seatInfo.status === 'occupied') {\n    color = SEAT_COLORS.occupied;\n  } else if (seatInfo.status === 'selected') {\n    color = seatInfo.selectedBy === userId ? \n      SEAT_COLORS.selected : SEAT_COLORS.selectedByOther;\n  } else if (hoveredSeat === seatId) {\n    color = SEAT_COLORS.hover;\n  }\n\n  // 绘制圆角矩形座位\n  ctx.fillStyle = color;\n  ctx.beginPath();\n  ctx.roundRect(x, y, SEAT_SIZE, SEAT_SIZE, 5);\n  ctx.fill();\n};\n\n多状态定义\n定义了五种座位状态，每种状态都有独特的视觉表现：\nconst SEAT_COLORS = {\n  available: '#4CAF50',      // 可选 - 绿色\n  selected: '#2196F3',       // 已选 - 蓝色\n  occupied: '#F44336',       // 已售 - 红色\n  selectedByOther: '#FF9800', // 他人已选 - 橙色\n  hover: '#81C784'           // 悬停 - 浅绿色\n};\n\n2. 实时协作\nWebSocket通信\n使用Socket.IO实现双向实时通信：\n客户端连接管理：\nuseEffect(() => {\n  const newSocket = io('http://localhost:3001');\n  setSocket(newSocket);\n\n  // 接收初始座位数据\n  newSocket.on('seatData', (data) => {\n    setSeatData(data);\n  });\n\n  // 监听座位状态更新\n  newSocket.on('seatUpdated', ({ seatId, seat }) => {\n    setSeatData(prev => ({\n      ...prev,\n      seats: {\n        ...prev.seats,\n        [seatId]: seat\n      }\n    }));\n  });\n\n  return () => newSocket.close();\n}, []);\n\n服务端事件处理：\nio.on('connection', (socket) => {\n  console.log('User connected:', socket.id);\n  \n  // 发送当前座位数据\n  socket.emit('seatData', seatData);\n  \n  // 处理座位选择\n  socket.on('selectSeat', (data) => {\n    const { seatId, userId } = data;\n    const seat = seatData.seats[seatId];\n    \n    // 业务逻辑验证\n    if (seat.status === 'occupied') {\n      socket.emit('error', { message: 'Seat is already occupied' });\n      return;\n    }\n    \n    // 切换选择状态\n    if (seat.status === 'selected' && seat.selectedBy === userId) {\n      seat.status = 'available';\n      seat.selectedBy = null;\n    } else {\n      seat.status = 'selected';\n      seat.selectedBy = userId;\n    }\n    \n    // 广播给所有客户端\n    io.emit('seatUpdated', { seatId, seat });\n  });\n});\n\n用户会话管理\n每个用户获得唯一标识符，确保座位选择的准确归属：\nconst [userId] = useState(() => Math.random().toString(36).substr(2, 9));\n\n当用户断开连接时，系统自动清理其选择的座位：\nsocket.on('disconnect', () => {\n  console.log('User disconnected:', socket.id);\n  \n  // 清除该用户选择的座位\n  Object.keys(seatData.seats).forEach(seatId => {\n    const seat = seatData.seats[seatId];\n    if (seat.status === 'selected' && seat.selectedBy === socket.id) {\n      seat.status = 'available';\n      seat.selectedBy = null;\n      io.emit('seatUpdated', { seatId, seat });\n    }\n  });\n});\n\n3. 交互\n像素级点击检测\n实现了精确的鼠标事件处理，支持像素级的点击检测：\nconst handleCanvasClick = (event) => {\n  if (!seatData || !socket) return;\n\n  const canvas = canvasRef.current;\n  const rect = canvas.getBoundingClientRect();\n  const x = event.clientX - rect.left;\n  const y = event.clientY - rect.top;\n\n  // 遍历所有座位进行碰撞检测\n  for (let row = 0; row < seatData.rows; row++) {\n    for (let seat = 0; seat < seatData.seatsPerRow; seat++) {\n      const seatX = CANVAS_PADDING + seat * SEAT_SPACING + (seat >= 6 ? AISLE_WIDTH : 0);\n      const seatY = CANVAS_PADDING + 60 + row * ROW_SPACING;\n\n      if (x >= seatX && x <= seatX + SEAT_SIZE && \n          y >= seatY && y <= seatY + SEAT_SIZE) {\n        const seatId = `${row}-${seat}`;\n        const seatInfo = seatData.seats[seatId];\n\n        if (seatInfo && seatInfo.status !== 'occupied') {\n          socket.emit('selectSeat', { seatId, userId });\n        }\n        return;\n      }\n    }\n  }\n};\n\n实时悬停效果\n实现了流畅的鼠标悬停效果，提供即时的视觉反馈：\nconst handleCanvasMouseMove = (event) => {\n  if (!seatData) return;\n\n  const canvas = canvasRef.current;\n  const rect = canvas.getBoundingClientRect();\n  const x = event.clientX - rect.left;\n  const y = event.clientY - rect.top;\n\n  let foundSeat = null;\n\n  // 查找鼠标悬停的座位\n  for (let row = 0; row < seatData.rows; row++) {\n    for (let seat = 0; seat < seatData.seatsPerRow; seat++) {\n      const seatX = CANVAS_PADDING + seat * SEAT_SPACING + (seat >= 6 ? AISLE_WIDTH : 0);\n      const seatY = CANVAS_PADDING + 60 + row * ROW_SPACING;\n\n      if (x >= seatX && x <= seatX + SEAT_SIZE && \n          y >= seatY && y <= seatY + SEAT_SIZE) {\n        foundSeat = `${row}-${seat}`;\n        break;\n      }\n    }\n    if (foundSeat) break;\n  }\n\n  if (foundSeat !== hoveredSeat) {\n    setHoveredSeat(foundSeat);\n  }\n};\n\n4. 数据管理与API\nRESTful API\n// 获取座位数据\napp.get('/api/seats', (req, res) => {\n  res.json(seatData);\n});\n\n// 选择座位\napp.post('/api/seats/select', (req, res) => {\n  const { seatId, userId } = req.body;\n  // 业务逻辑处理...\n});\n\n// 购买座位\napp.post('/api/seats/book', (req, res) => {\n  const { seatIds, userId } = req.body;\n  \n  const bookedSeats = [];\n  const errors = [];\n  \n  seatIds.forEach(seatId => {\n    const seat = seatData.seats[seatId];\n    if (seat.status === 'selected' && seat.selectedBy === userId) {\n      seat.status = 'occupied';\n      seat.selectedBy = null;\n      bookedSeats.push(seat);\n    } else {\n      errors.push(`Seat ${seatId} is not selected by you`);\n    }\n  });\n  \n  if (errors.length > 0) {\n    return res.status(400).json({ errors });\n  }\n  \n  res.json({ success: true, bookedSeats });\n});\n\n状态管理策略\n采用React Hooks进行客户端状态管理：\nconst [seatData, setSeatData] = useState(null);\nconst [socket, setSocket] = useState(null);\nconst [hoveredSeat, setHoveredSeat] = useState(null);\n\n// 获取选中座位信息\nconst getSelectedSeatsInfo = () => {\n  if (!seatData) return [];\n  \n  return Object.values(seatData.seats)\n    .filter(seat => seat.status === 'selected' && seat.selectedBy === userId)\n    .sort((a, b) => a.row - b.row || a.seat - b.seat);\n};",
      "hotIndex": 9,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7564921269491580943",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "不用再配服务器了！这套 Next.js + Cloudflare 模板，一个人零成本搞定全栈出海",
      "url": "https://juejin.cn/post/7564921269491580943",
      "pubDate": "Sun, 26 Oct 2025 07:25:42 GMT",
      "description": "作为开发者，我们都想快速验证自己的想法，尤其是在海外市场。但一想到要配服务器、搞数据库、CDN、CI/CD... 一个人基本就被劝退了。\n这篇文章，我想分享一个开源模板，它把这套事儿全包了。\n核心就是：一个人、零成本、用 Next.js + Cloudflare 生态搞定全栈出海。\nGitHub 仓库： github.com/TangSY/edge…\n在线 Demo： 7723b3e2.cloudflare-worker-template-prod.pages.dev/\n这篇文章特别适合：独立开发者、早期初创团队，或者任何需要快速验证海外市场的工程师。\n为什么说“一个人就能搞定”？\n说“一个人就能搞”，不是吹牛。核心是这个模板已经把最繁琐的“脏活累活”干完了。\n你不用再从零开始搭架子。这个模板把一个全栈应用需要的东西都分好类，并提供了最佳实践：\n前端： Next.js 15.5.2 (App Router + TypeScript)\n后端： Cloudflare Pages Functions (Edge Runtime)，API 路由开箱即用\n数据： Prisma ORM + D1 数据库\n存储： R2 对象存储\n缓存： KV 键值存储\n观测： 结构化日志 + Analytics 事件\n工程： 统一响应/错误/中间件/速率限制\n测试： Vitest\n部署： Wrangler + GitHub Actions\n你能真正专注于业务本身：页面、数据模型、接口逻辑。其余的“工程必需品”——日志、限流、错误、响应格式、缓存、上传、健康检查、多环境配置、CI/CD——都已默认提供。\n对你来说，这意味着：\n节省大量时间： 减少 70% 以上的重复配置工作。\n不用纠结选型： 直接用 Next.js + Cloudflare 这套统一的现代技术栈。\n部署无忧： 环境变量、CI/CD 脚本和文档都已备好，照着跑就行。\n轻松上手：5 步跑通全栈\n上手不难，这个模板把关键步骤都脚本化了。你只需要准备好这几样东西：\nNode.js >= 20 (项目里有 .nvmrc)\npnpm >= 8\n一个 Cloudflare 账户（需要开通 Pages/Workers/D1/R2/KV）\n然后，跟着 QUICKSTART-zh.md 文档，5 步就能跑起来：\n初始化： pnpm i 装好依赖，wrangler login 登录 Cloudflare。\n配环境： 配置 wrangler.toml (本地)、wrangler.test.toml (测试) 和 wrangler.prod.toml (生产)。\n建资源：\n\nD1 (数据库): pnpm run db:migrate:local\nR2 (存储): pnpm run r2:create:test (或 prod)\nKV (缓存): pnpm run kv:create:test (或 prod)\n跑开发：\n\n本地开发 (Next.js): pnpm dev\n模拟 Cloudflare 环境: pnpm run cf:dev\n一部署：\n\n测试环境: pnpm run pages:deploy:test\n生产环境: pnpm run pages:deploy:prod\n如果顺利，你一天内就能跑通 Demo，一周内就能上线 MVP 去验证海外访问体验。\n零成本起步：Cloudflare 免费额度有多香？\n“完全免费”是这套方案最大的诱惑。Cloudflare 的 Free Tier 真的非常大方，用来做 MVP 甚至中小流量项目绰绰有余（具体以官方最新文档为准）：\nPages (静态托管)\n\n项目数量：100 个\n每月构建：500 次\n带宽/静态请求：无限制\nPages Functions (与 Workers 共享额度)\n\n每日请求：100,000 次\nCPU 时间：每次请求 10 毫秒\nD1 Database (数据库)\n\n数据库数量：10 个\n总存储：5 GB (所有库共享)\nR2 Storage (对象存储)\n\n核心优势：零出站费用 (Egress Zero)，这点对出海太重要了。\n这些额度对个人开发者太友好了。你能零服务器成本跑一个真实的全栈应用。\n完整的生态：不止是拼凑\n这个模板不是简单地把 Next.js 和 Cloudflare 拼在一起，而是把它们的原生生态“串”成了一个有机的整体。它为你规划好了每个组件的职责：\n前端/页面： Next.js App Router 负责承载 UI，SSR/SSG/ISR 这些能力都有，Tailwind CSS 也已配好。\n后端/API： 运行在 Edge Runtime 上的 Next.js 路由 (app/api/*) 负责处理业务逻辑。\n数据/ORM： Prisma 配合 @prisma/adapter-d1 连接 D1 数据库，享受类型安全和关系查询。\n缓存： KV 作为高性能键值存储，用于缓存热点数据。\n存储： R2 负责对象存储，适合图片/附件上传，对 CDN 友好。\n可观测性： 结构化日志 (pino) 和 Analytics Engine 负责事件打点，方便排查问题。\n部署： Wrangler 统一驱动本地开发和多环境（local/test/prod）部署。\n规范/工程： 统一的错误类型、Repository 模式分层、CI/CD 自动化。\n你不需要再折腾“如何把这些拼好”，直接用即可。\n为什么说它适合“出海”？\n海外用户最关心两件事：访问速度和稳定性。\n这套方案天生就是为全球访问设计的：\n全球边缘节点： 你的应用和服务（Pages/Workers）都在 Cloudflare 的全球 POP 上，用户就近接入，延迟自然低。\nD1 边缘数据库： 轻中量业务非常合适，能减少数据库跨区查询的延迟。\nR2 零出站费： 海外用户下载图片/文件，你不必支付高昂的流量费，成本结构极优。\n边缘缓存 (KV)： 以极低延迟服务热点数据。\n轻松多环境： 测试与生产分离，按分支策略（develop→test, main→prod）自动部署。\n这套栈能让你“快速上线、稳定运行、低成本迭代”，把精力真正花在试错和打磨产品上。\n模板里的一些“私货”：工程亮点\n这部分是模板的“私货”。只提供组件拼凑是不够的，我们把生产环境中必须的工程实践都标准化了。\ngraph TD\n    A[User Request] --> B(Cloudflare Edge / Next.js API Route);\n\n    subgraph \"请求处理管道 (Request Pipeline)\"\n        B --> C(1. 统一中间件 <br> withMiddleware);\n        C --> D(2. 速率限制 <br> withRateLimit);\n        D --> E{3. 检查缓存? <br> withCache};\n    end\n    \n    subgraph \"数据与服务 (Data & Services)\"\n        %% 修正了这里：为 K 节点的文本加上了双引号\n        K[(\"KV <br> (Cache / Rate Limit)\")]\n        I[(D1 数据库)];\n        J[(R2 对象存储)];\n        L((可观测性 <br> 日志 / Analytics));\n    end\n\n    subgraph \"业务逻辑层 (Business Logic)\"\n        F(4. API 核心逻辑);\n        G(5. 仓储层 <br> withRepositories);\n        H(\"6. Prisma Client (单例)\");\n    end\n\n    M(Response)\n\n    %% 流程连线\n    C -.-> L;\n    D --> K;\n    E -- \"Hit (命中)\" --> M;\n    E -- \"Miss (未命中)\" --> F;\n    F --> G;\n    G --> H;\n    H --> I;\n    F -- \"e.g. Upload API\" --> J;\n    \n    %% 异步打点\n    F -.-> L;\n    G -.-> L;\n\n    F --> M;\n    M --> A;\n\n统一 API 响应与中间件\nlib/api/response.ts 定义了 success/error 的结构，errorResponse 会自动映射错误类型和状态码。\nlib/api/middleware.ts 自动注入 requestId，记录请求耗时，并追加追踪头。\n错误类型体系\nlib/errors/index.ts 定义了十多种常见的错误类型（数据库、验证、认证、限流等）。\nERROR_STATUS_MAP 统一管理 HTTP 状态码，让错误处理更规范。\n结构化日志（生产 JSON、开发 Pretty）\nlib/logger/index.ts 支持 http(), performance(), query() 等专用方法，还能配慢查询阈值。\nAnalytics 事件打点\nlib/analytics/index.ts 定义了各种业务事件，可选择 Sink（例如打到 D1 或 KV），失败自动降级到日志。\n速率限制（KV 滑动窗口）\nlib/api/rate-limit.ts 利用 KV 的原子性实现了滑动窗口限流。默认每分钟 300 次，但你可以在路由上自定义，比如限制创建用户接口为 10/min。\nRepository 模式 + Prisma + D1 单例\nrepositories/* 封装了数据访问，lib/api/database.ts 提供了 withRepositories 注入。\n核心优化： lib/db/client.ts 做了 PrismaClient 单例复用。这至关重要，能为你减少 50–100ms 的数据库冷启动开销。\n开箱即用的缓存装饰器\nlib/cache/client.ts 提供了 withCache(key, fn, ttl) 装饰器，用起来非常方便，自动处理缓存的命中、穿透和回源。\n封装 R2 上传与下载\nlib/r2/client.ts 封装了上传下载，app/api/upload/route.ts 是一个完整示例，你不需要关心 S3 复杂的 SDK。\n健康检查端点\napp/api/health/route.ts 提供了一个端点，用于 CI/CD 或监控系统检测 D1/R2/KV 的可用性。\nCI/CD 与变更记录\n.github/workflows/* 负责 CI/Deploy。\nrelease-please 用来自动管理 CHANGELOG。\n实践路径：从零到 MVP\n我建议的实践路径是这样的：\nDay 1：跑通与上线 Demo\nFork 项目，配置好 Cloudflare 账户和 Wrangler，创建 D1/R2/KV 并绑定。\n本地跑通 pnpm dev 和 pnpm run cf:dev，确保 Edge API 正常。\n跑通迁移脚本，验证 /api/health、/api/users 等核心接口。\n部署到测试环境 pnpm run pages:deploy:test。\nDay 2–3：定制你的业务模型\n修改 prisma/schema.prisma，加入你自己的模型（比如 Comment/Order）。\n在 repositories/* 目录新增你的数据仓储（参考 users.repository.ts）。\n在 app/api/* 目录新增你的路由，统一使用 withRepositories + withMiddleware；需要缓存和限流的加上 withCache / withRateLimit。\n推到生产环境 pnpm run pages:deploy:prod，观察日志和 Analytics 事件。\nDay 4–7：出海验证与优化\n这时候就要开始关注真实数据了：访问热点接口（比如列表页）加上 withCache。\n保护好你的写操作（比如注册、下单）和外部服务集成，调整限流策略。\n观测慢查询和慢操作（通过 logger.query/performance + Analytics）。\n看看海外用户的反馈，快速迭代。\n成本与扩展：免费起步，平滑升级\n免费层能跑多久？\n我的经验是，做 MVP 和中小流量（日 10 万请求）绝对够用。5GB 的 D1 存储也够支撑一段时间了。R2 的零出站费更是一个巨大的成本优势。\n未来如何扩展？\n当你的业务增长后，这套架构也能平滑升级：\n数据： 读写压力大了，优先上读缓存（KV）；再不行就考虑外挂专业的托管数据库（如 PlanetScale），把 Edge 作为 BFF 层。\n存储： R2 本身性能很强，主要是管理策略。\n观测： Analytics Engine 可以持久化数据，或对接外部可观测平台。\n常见问题 (FAQ)\nQ1：为什么选 Next.js + Cloudflare？\nA：前端生态成熟 + Edge 原生运行时。对我（独立开发者）来说，没有服务器维护成本、全球 POP 优势、和 D1/R2/KV 一体化，这几点是决定性的。\nQ2：会不会很难上手？\nA：如果你是 Next.js 开发者，基本没有门槛。模板把最难的工程部分（数据库连接、日志、部署）都包了，你只需要写业务。\nQ3：免费层真的够用吗？\nA：绝对够。做 MVP 和中小流量没问题。上线后盯一下 Cloudflare 的用量统计，快超了再升级或优化。\nQ4：如何面向海外做优化？\nA：核心就是“靠近用户”。充分利用边缘缓存 (KV)、R2 零出站费、SSR/SSG/ISR，减少跨区往返。给接口加上 withCache 和合理的 Cache-Control 头。\nQ5：如何扩展复杂业务？\nA：通过 Repository 模式扩展数据访问层；在 API 层统一用 withRepositories + withMiddleware。Prisma 本身支持事务、分页、过滤等。\n结语：把精力还给产品\n如果你也是个独立开发者或小团队，正苦于出海项目的启动成本和复杂度，我希望这套模板能帮你省下大量搭建基础设施的时间。\n“一个人就能搞定出海全栈”不是口号，而是一种可行的实践。\n🚀 立刻开始：一天内上线你的出海应用\n别再犹豫了。你的下一个伟大想法，不该死在繁琐的服务器配置上。\n立即 Fork 仓库，开始构建：\nhttps://github.com/TangSY/edge-next-starter\n祝你出海顺利。",
      "hotIndex": 10,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7564681385294921737",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "h5后台切换检测利用visibilitychange的缺点分析",
      "url": "https://juejin.cn/post/7564681385294921737",
      "pubDate": "Fri, 24 Oct 2025 14:51:59 GMT",
      "description": "一、什么是 visibilitychange 事件？\nvisibilitychange 是浏览器提供的原生事件，属于 Page Visibility API（页面可见性 API）的核心部分。当页面的可见性状态发生变化时（如页面从 “显示” 变为 “隐藏”，或从 “隐藏” 变为 “显示”），浏览器会触发该事件，当然如果是uniapp或者是wx也会提供类似apphide appshow这些API。\n核心作用：判断页面是否处于用户可见状态（前台）或不可见状态（后台，如切换到其他 App、浏览器标签页被切换、手机锁屏等）。\n二、核心属性与事件\n1. document.hidden（状态判断核心）\n布尔值，true 表示页面当前不可见（后台），false 表示页面可见（前台）。\n是判断页面状态的直接依据。\n2. document.visibilityState（更详细的状态描述）\n字符串类型，返回页面的具体可见性状态，有 4 种可能值：\nvisible：页面可见（至少部分可见，如浏览器窗口未最小化，标签页激活）。\nhidden：页面不可见（如切换到其他标签页、浏览器最小化、手机切后台）。\nprerender：页面正在预渲染（用户未实际看到，通常用于优化加载，部分浏览器支持）。\nunloaded：页面即将被卸载（如关闭标签页，部分浏览器支持）。\n实际开发中，hidden 和 visible 是最常用的两个状态。\n3. visibilitychange 事件\n当 document.visibilityState 或 document.hidden 变化时触发，需通过 document.addEventListener 监听。\n三、基本用法（完整代码示例）\n1. 基础监听逻辑\n// 监听 visibilitychange 事件\ndocument.addEventListener('visibilitychange', handleVisibilityChange);\n\n// 事件处理函数\nfunction handleVisibilityChange() {\n  // 方法1：用 document.hidden 判断\n  if (document.hidden) {\n    console.log('页面进入后台（不可见）');\n    // 执行后台逻辑：暂停视频、清除定时器、保存数据等\n    pauseVideo();\n    clearInterval(timer);\n    saveUserState();\n  } else {\n    console.log('页面回到前台（可见）');\n    // 执行前台逻辑：恢复视频播放、重启定时器、刷新数据等\n    playVideo();\n    restartTimer();\n    refreshData();\n  }\n\n  // 方法2：用 document.visibilityState 判断（更细致）\n  switch (document.visibilityState) {\n    case 'visible':\n      console.log('页面可见（前台）');\n      break;\n    case 'hidden':\n      console.log('页面隐藏（后台）');\n      break;\n    case 'prerender':\n      console.log('页面预渲染中');\n      break;\n    case 'unloaded':\n      console.log('页面即将卸载');\n      break;\n  }\n}\n\n2. 解除监听（避免内存泄漏）\n当页面不需要监听状态变化时（如组件销毁），需移除事件监听：\n// 页面卸载前解除监听\nwindow.addEventListener('beforeunload', function() {\n  document.removeEventListener('visibilitychange', handleVisibilityChange);\n});\n\n// 或在 Vue/React 组件销毁时（以 Vue 为例）\nexport default {\n  beforeDestroy() {\n    document.removeEventListener('visibilitychange', this.handleVisibilityChange);\n  }\n};\n\n四、适用场景\n1. 媒体播放控制\n页面切后台时暂停视频 / 音频，切回前台时恢复播放：\nconst video = document.getElementById('myVideo');\nfunction handleVisibilityChange() {\n  if (document.hidden) {\n    video.pause(); // 切后台暂停\n  } else {\n    video.play(); // 切前台恢复\n  }\n}\n\n2. 减少无效请求\n页面在后台时，暂停轮询接口（如实时聊天、数据刷新），避免浪费资源：\nlet pollTimer;\nfunction startPoll() {\n  pollTimer = setInterval(() => {\n    fetch('/api/refresh'); // 轮询接口\n  }, 5000);\n}\nfunction stopPoll() {\n  clearInterval(pollTimer);\n}\n\nfunction handleVisibilityChange() {\n  if (document.hidden) {\n    stopPoll(); // 后台停止轮询\n  } else {\n    startPoll(); // 前台重启轮询\n  }\n}\n\n3. 记录用户在线状态\n切后台时记录 “离线时间”，切前台时更新 “在线状态”：\nlet lastLeaveTime;\nfunction handleVisibilityChange() {\n  if (document.hidden) {\n    lastLeaveTime = new Date().getTime(); // 记录切后台时间\n    reportUserState('offline'); // 上报离线状态\n  } else {\n    const onlineTime = new Date().getTime() - lastLeaveTime;\n    console.log(`用户离线时长：${onlineTime}ms`);\n    reportUserState('online'); // 上报在线状态\n  }\n}\n\n4. 防止表单数据丢失\n切后台时自动保存表单草稿，避免用户忘记提交：\nfunction saveFormDraft() {\n  const formData = {\n    username: document.getElementById('username').value,\n    content: document.getElementById('content').value\n  };\n  localStorage.setItem('formDraft', JSON.stringify(formData));\n}\n\nfunction handleVisibilityChange() {\n  if (document.hidden) {\n    saveFormDraft(); // 切后台时保存草稿\n  }\n}\n\n五、兼容性与浏览器支持\n1. 主流浏览器支持情况\nPC 端：Chrome、Firefox、Edge、Safari（≥6.1）全支持。\n移动端：微信内置浏览器、手机 Chrome、Safari（iOS ≥7.1）、安卓系统浏览器（≥4.4）全支持。\n低版本兼容：IE10+ 支持，但需用前缀 msVisibilityChange 和 msHidden（实际开发中可忽略，IE 市场占比极低）。\n六、注意\n1. 与 pagehide/pageshow 的区别\nvisibilitychange：仅关注页面 “可见性”（是否在前台），不关心页面是否卸载（如切换标签页时触发，但页面未关闭。\npagehide：页面即将被卸载时触发（如关闭标签页、跳转页面），但切后台时也可能触发，场景更宽泛，判断精度低于 visibilitychange。\n结论：判断 “切后台” 优先用 visibilitychange，判断 “页面关闭” 可用 pagehide。\n2. 微信 / 企业微信环境的特殊性\n微信内置浏览器完全支持 visibilitychange，无需依赖微信 JS-SDK，可直接使用。\n但需注意：微信中 “分享到朋友圈 / 好友” 时，页面会短暂切后台再切回，可能触发一次 visibilitychange（从 visible → hidden → visible），需根据业务判断是否忽略这种场景。\n3. 避免过度使用\n频繁触发的逻辑（如大量 DOM 操作）放在 visibilitychange 中可能影响性能，建议仅处理必要操作（如暂停 / 恢复、保存数据）。\n4. 锁屏状态的触发\n手机锁屏时，页面会被视为 “隐藏”，触发 visibilitychange（document.hidden = true）；解锁后恢复，触发 visible。\nvisibilitychange 事件是 H5 页面监听 “前台 / 后台切换” 的最优方案，具有以下优势：\n原生支持：无需依赖任何 SDK（包括微信 / 企业微信），兼容性极佳。\n精准可靠：能覆盖 “切 App、切换标签页、锁屏” 等所有页面可见性变化场景。\n用法简单：通过 document.hidden 或 visibilityState 即可判断状态，代码逻辑清晰。\n缺点:无法区分隐藏原因\n是的，你没看错，先前讲到的只是常规情况下用户手动切换后台的触发，\n但是在一些场景下还是要慎用\n1. 无法区分 “切后台” 的具体原因\nvisibilitychange 只能判断页面 “可见” 或 “隐藏”，但无法区分隐藏的具体场景，例如：\n用户是 “切换到其他 App” 还是 “切换到浏览器的其他标签页”？\n是 “手机锁屏” 还是 “浏览器窗口最小化”？\n是 “分享到微信好友后暂时离开” 还是 “彻底关闭页面”？\n2. 部分浏览器 / 场景下触发时机不精准\n微信 / 支付宝等 App 内置浏览器：在某些操作（如点击分享、拉起原生组件）时，可能会出现 “短暂隐藏再恢复” 的误触发。例如，在微信中点击 “分享到朋友圈”，页面会先切后台（触发 hidden），分享完成后切回前台（触发 visible），但用户实际并未离开页面，可能干扰业务逻辑（如暂停的视频被误触发播放 / 暂停）。\niOS 端的特殊行为：在 iOS Safari 中，当页面处于后台且内存不足时，浏览器可能会冻结页面 JS 执行，导致 visibilitychange 事件在页面恢复时延迟触发，或部分逻辑（如定时器）无法正常执行。\n3. 无法监听 “页面关闭” 的最终状态\nvisibilitychange 的 unloaded 状态在多数浏览器中支持不佳，且页面真正关闭时（如用户点击关闭标签页），visibilitychange 可能与 beforeunload、pagehide 事件顺序混乱，难以可靠判断 “用户是否彻底离开”。例如，用户关闭标签页时，hidden 会先变为 true，但此时页面即将卸载，后续逻辑（如上报数据）可能因页面关闭而中断。\n4. 对 “部分可见” 状态的判断有限\ndocument.visibilityState = 'visible' 表示页面 “至少部分可见”（如浏览器窗口只露出一小块），但无法判断页面是否 “完全可见”（如被其他窗口遮挡了大部分）。如果业务需要精确判断 “用户是否正在全屏浏览”，visibilitychange 无法满足，需结合 document.fullscreenElement 等 API 辅助判断。\n用户是 “切换到其他 App” 还是 “切换到浏览器的其他标签页”？\n是 “手机锁屏” 还是 “浏览器窗口最小化”\n是 “分享到微信好友后暂时离开” 还是 “彻底关闭页面”？\n上面三种是常见的场景，通常可以这样的辅助方法进行判断\n一、区分 “切换到其他 App” vs “切换到浏览器其他标签页”\n核心思路：利用浏览器标签页的 “焦点状态” 和 “页面可见性” 的关联性\n切换到浏览器其他标签页时：页面失去焦点（window.blur）且可见性变为隐藏（document.hidden = true），但浏览器进程仍在运行，setTimeout 等定时器可能继续执行（取决于浏览器优化策略）。\n切换到其他 App时：页面不仅隐藏（document.hidden = true），还可能伴随浏览器进程被 “冻结”（尤其是移动端），定时器执行会延迟或暂停。\n辅助判断方法：\n结合 focus/blur 事件与定时器延迟检测（一般情况可用，所以慎用）：\nlet isTabSwitch = false;\nlet timer;\n\n// 监听可见性变化\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) {\n    // 页面隐藏时启动定时器，检测延迟\n    timer = setTimeout(() => {\n      // 若定时器延迟超过100ms，大概率是切换到其他App（浏览器被冻结）\n      console.log('可能切换到其他App');\n    }, 100);\n  } else {\n    clearTimeout(timer);\n    // 页面恢复时，若之前触发了blur且无明显延迟，可能是切换标签页\n    if (isTabSwitch) {\n      console.log('可能切换到浏览器其他标签页');\n      isTabSwitch = false;\n    }\n  }\n});\n\n// 监听焦点变化\nwindow.addEventListener('blur', () => {\n  if (document.hidden) {\n    isTabSwitch = true; // 隐藏时失去焦点，可能是切换标签页\n  }\n});\n\n原理：切换标签页时，浏览器仍在前台运行，定时器延迟较小；切换到其他 App 时，浏览器进入后台，定时器可能被延迟执行。\n二、区分 “手机锁屏” vs “浏览器窗口最小化”\n核心思路：利用 “锁屏” 的特殊性 —— 通常伴随设备屏幕关闭，而 “窗口最小化” 仅窗口不可见\n手机锁屏时：屏幕完全关闭，浏览器可能触发 visibilitychange 且后续操作（如触摸事件）完全失效。\n浏览器窗口最小化（PC 端）：屏幕仍亮，只是窗口不可见。\n辅助判断方法：\n结合 screen 对象的亮度或唤醒状态（移动端有限支持）：\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) {\n    // 检测屏幕是否变暗（部分设备支持）\n    if (typeof screen.brightness !== 'undefined' && screen.brightness < 0.1) {\n      console.log('可能是手机锁屏');\n    } else {\n      console.log('可能是浏览器窗口最小化');\n    }\n  }\n});\n\n注意：screen.brightness 兼容性较差（主要支持安卓部分浏览器），iOS 基本不支持。\n监听 touchstart 事件是否失效（移动端）：锁屏后，页面无法接收触摸事件，可在页面恢复可见时检测是否有 “锁屏期间的触摸记录”（无记录则可能是锁屏）：\nlet hasTouchDuringHidden = false;\ndocument.addEventListener('touchstart', () => {\n  if (document.hidden) {\n    hasTouchDuringHidden = true;\n  }\n});\n\ndocument.addEventListener('visibilitychange', () => {\n  if (!document.hidden) {\n    if (!hasTouchDuringHidden) {\n      console.log('可能是手机锁屏（期间无触摸）');\n    } else {\n      console.log('可能是窗口最小化（期间可能有触摸其他窗口）');\n      hasTouchDuringHidden = false;\n    }\n  }\n});\n\n三、区分 “分享到微信好友后暂时离开” vs “彻底关闭页面”\n核心思路：利用 “分享” 操作的前置行为（如点击分享按钮）和页面生命周期差异\n分享到微信好友后暂时离开：用户点击分享按钮 → 页面隐藏 → 分享完成后用户可能返回，页面会再次触发 visible。\n彻底关闭页面：页面隐藏后，会接着触发 pagehide 或 beforeunload 事件，且不会再恢复 visible。\n辅助判断方法：\n监听微信分享按钮的点击事件（微信 H5 场景）：在微信环境中，用户分享前通常会点击自定义的 “分享按钮”，可通过该行为标记 “可能是分享导致的离开”：\nlet isSharing = false;\n// 假设分享按钮id为shareBtn\ndocument.getElementById('shareBtn').addEventListener('click', () => {\n  isSharing = true; // 标记用户触发了分享操作\n});\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) {\n    if (isSharing) {\n      console.log('可能是分享到微信好友后暂时离开');\n      // 30秒后若未恢复可见，视为可能关闭页面\n      setTimeout(() => {\n        if (document.hidden) {\n          console.log('分享后未返回，可能已关闭页面');\n          isSharing = false;\n        }\n      }, 30000);\n    } else {\n      console.log('可能是其他原因关闭页面');\n    }\n  } else {\n    if (isSharing) {\n      console.log('分享后返回页面');\n      isSharing = false;\n    }\n  }\n});\n\n结合 pagehide 事件判断页面是否卸载：彻底关闭页面时，pagehide 事件会在 visibilitychange 之后触发，可通过该事件确认 “页面已关闭”：\nlet isPageClosed = false;\nwindow.addEventListener('pagehide', () => {\n  isPageClosed = true;\n  console.log('页面已关闭');\n});\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden && !isPageClosed) {\n    console.log('页面隐藏但未关闭（可能是分享后暂时离开）');\n  }\n});\n\n总结：\n没有绝对的完美，只有不断地完善，当后台切换时还是要尽可能的与原有应用进行事件关联才会更准确的判断用户的操作行为。",
      "hotIndex": 11,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7564597313466122266",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "1024程序员节：用不到100行代码做个“代码雨屏保”装X神器（附源码）",
      "url": "https://juejin.cn/post/7564597313466122266",
      "pubDate": "Fri, 24 Oct 2025 07:26:16 GMT",
      "description": "在1024程序员节，整点有意思的东西很重要。今天分享一个代码不到100行超轻量的Chrome插件：在任意网页按 Alt+M，一键触发“黑客帝国”风格的代码雨屏保，装X效果直接拉满，下面直接上效果与源码。\n效果预览\n\n按 Alt+M：屏幕进入黑底绿字的代码雨模式\n再按 Alt+M：退出屏保\n支持在任何网页触发，不影响页面操作\n完整源码\n项目结构\n1024\n├── manifest.json      # 扩展的\"身份证\n└── content.js         # 核心代码雨逻辑\n\n第一步：创建项目文件\n创建文件夹 1024\n创建manifest.json文件\n{\n  \"manifest_version\": 3,\n  \"name\": \"1024\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Press Alt+M to trigger Matrix rain effect\",\n  \"content_scripts\": [\n    {\n      \"matches\": [\"<all_urls>\"],\n      \"js\": [\"content.js\"],\n      \"run_at\": \"document_end\"\n    }\n  ]\n}\n\n\n创建content.js文件\n// 防止重复注入\nif (!window.matrixRainInjected) {\n  window.matrixRainInjected = true;\n\n  let isRaining = false;\n  let canvas, ctx, animationId;\n\n  // 监听快捷键 Alt+M\n  document.addEventListener('keydown', (e) => {\n    if (e.altKey && e.key.toLowerCase() === 'm') {\n      e.preventDefault();\n      toggleMatrixRain();\n    }\n  });\n\n  function toggleMatrixRain() {\n    if (isRaining) {\n      stopRain();\n    } else {\n      startRain();\n    }\n  }\n\n  function startRain() {\n    isRaining = true;\n\n    // 隐藏页面滚动条\n    document.documentElement.style.overflow = 'hidden';\n\n    // 创建全屏Canvas\n    canvas = document.createElement('canvas');\n    canvas.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100vw;\n      height: 100vh;\n      z-index: 2147483647;\n      pointer-events: auto !important;\n      background: rgba(0, 0, 0, 0.9);\n    `;\n    document.body.appendChild(canvas);\n\n    ctx = canvas.getContext('2d');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n\n    // 简化字符集\n    const chars = 'CODE1024';\n    const charArray = chars.split('');\n\n    const fontSize = 16;\n    const columns = Math.floor(canvas.width / fontSize);\n    const drops = Array(columns).fill(1);\n\n    // 动画循环\n    function draw() {\n      // 半透明黑色背景，产生拖尾效果\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      ctx.fillStyle = '#0F0'; // 绿色字体\n      ctx.font = fontSize + 'px monospace';\n\n      for (let i = 0; i < drops.length; i++) {\n        // 随机字符\n        const text = charArray[Math.floor(Math.random() * charArray.length)];\n        const x = i * fontSize;\n        const y = drops[i] * fontSize;\n\n        ctx.fillText(text, x, y);\n\n        // 随机重置或继续下落\n        if (y > canvas.height && Math.random() > 0.975) {\n          drops[i] = 0;\n        }\n        drops[i]++;\n      }\n\n      animationId = requestAnimationFrame(draw);\n    }\n\n    draw();\n\n    // 添加提示文字\n    setTimeout(() => {\n      const hint = document.createElement('div');\n      hint.style.cssText = `\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #0F0;\n        font-size: 24px;\n        font-family: monospace;\n        z-index: 9999999;\n        text-shadow: 0 0 10px #0F0;\n        pointer-events: none;\n        animation: fadeOut 3s forwards;\n      `;\n      hint.textContent = '[ Alt+M to exit ]';\n\n      // 添加淡出动画\n      const style = document.createElement('style');\n      style.textContent = `\n        @keyframes fadeOut {\n          0% { opacity: 1; }\n          70% { opacity: 1; }\n          100% { opacity: 0; }\n        }\n      `;\n      document.head.appendChild(style);\n      document.body.appendChild(hint);\n\n      setTimeout(() => hint.remove(), 3000);\n    }, 500);\n  }\n\n  function stopRain() {\n    isRaining = false;\n    if (animationId) {\n      cancelAnimationFrame(animationId);\n    }\n    if (canvas) {\n      canvas.remove();\n    }\n\n    // 恢复滚动条\n    document.documentElement.style.overflow = '';\n  }\n\n  // 窗口大小改变时重新调整\n  window.addEventListener('resize', () => {\n    if (isRaining && canvas) {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    }\n  });\n}\n\n\n原理解析（简明易懂）\nCanvas 全屏覆盖：创建一个固定定位的画布，覆盖整个视窗，设置 pointer-events: none，避免拦截点击。\n代码雨效果：把屏幕横向按字体大小切分成列，每列都有一个“落点”，逐帧绘制字符下落。\n拖尾实现：每一帧先用半透明黑色填充画布，让上一帧的内容渐隐，形成“拖尾”。\n快捷键切换：监听 Alt+M，调用 startRain/stopRain 函数进行切换。\n防重复注入：用 window.matrixRainInjected 标记，避免同一页面重复绑定。\n第二步： 安装与使用\n\n打开 Chrome，访问 chrome://extensions/\n打开右上角“开发者模式”\n点击“加载已解压的扩展程序”，选择 刚刚创建的1024 文件夹\n完成安装后，访问任意网页，按 Alt+M 开始，再按 Alt+M 退出\n总结\n这个小玩具，祝各位码农1024节快乐。\n如果觉得对您有帮助，欢迎点赞 👍 收藏 ⭐ 关注 🔔 支持一下！\n往期实战推荐：\nVue3 后台分页写腻了？我用 1 个 Hook 删掉 90% 重复代码（附源码）\n⚡ 一个Vue自定义指令搞定丝滑拖拽列表，告别复杂组件封装\n\n🔥 这才是 Vue 驱动的 Chrome 插件工程化正确打开方式\n【前端效率工具】：告别右键另存，不到 50 行代码一键批量下载网页图片\n 女朋友炸了：刚打开的网页怎么又没了？我反手甩出一键恢复按钮！\n 你家孩子又偷玩网页游戏? 试试这个防沉迷工具\n  她说想要浪漫，我把浏览器鼠标换成了柴犬，点一下就有烟花（附源码）",
      "hotIndex": 12,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7564243641860423718",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "Node.js 25 正式发布：性能飙升、安全升级、全面向 Web 靠拢！",
      "url": "https://juejin.cn/post/7564243641860423718",
      "pubDate": "Thu, 23 Oct 2025 12:46:35 GMT",
      "description": "一、Node.js 25 来了：一次更现代、更安全的“Web Runtime”进化\nNode.js 25.0.0 已于本周正式发布。\nV8 引擎升级（14.1），还正式引入 细粒度权限模型 与 默认启用的 Web Storage API，让 Node.js 在性能、安全性与 Web 标准兼容性上迈出关键一步。\n从整体趋势上看，Node.js 正在从“后端运行时”演化为一个 更贴近浏览器语义的通用执行平台。\n高性能 + 高安全 + 高兼容性。\n大家好，我是考拉！\n这是我历时 1 个多月翻译的 Nest.js中文文档（ V10.x 版本）。就在 1024 这天上线吧！网站访问速度还是蛮快的哦！\nNest中文文档访问地址 Nest中文文档  nestjs.inode.club\n二、V8 升级到 14.1：性能全面提升\nNode.js 25 最大的底层变化是 升级到 V8 14.1 引擎，这一版本带来了显著的性能与开发体验改进：\n1. JSON.stringify 大幅提速\nV8 优化了内部序列化逻辑，使 JSON.stringify 在处理大型对象时速度提升可达数倍，API 返回结果更稳定。\n2. 内置 Uint8Array Base64/Hex 转换\nNode.js 25 新增了 Uint8Array.toBase64() / Uint8Array.fromBase64() 等内置方法，\n// 示例：高效转换 Buffer ⇄ Base64\nconst buffer = Buffer.from('Hello, Node.js 25!');\nconst uint8 = new Uint8Array(buffer);\nconst base64 = uint8.toBase64();\n\nconsole.log(base64); // 'SGVsbG8sIE5vZGUuanMgMjUh'\n\n// 反向转换\nconst decoded = Uint8Array.fromBase64(base64);\nconsole.log(Buffer.from(decoded).toString()); // 'Hello, Node.js 25!'\n\n3. WebAssembly + JIT 优化\nV8 持续改进了 JIT pipeline 与 wasm 编译路径，模块加载与执行延迟进一步降低。\n三、安全模型全面增强：默认更安全的 Node.js\nNode.js 25 引入了新的 权限模型（Permission Model），这项实验性特性正在成为默认安全策略的核心部分。\n更细粒度的运行时控制\n--allow-net：是否允许网络访问\n--allow-inspector：是否允许调试访问\n--experimental-permission：启用权限模型\n这意味着开发者可以像在浏览器沙箱中一样，隔离敏感操作，防止包依赖被攻击或误用。\n// 示例：限制网络访问\nimport net from 'node:net';\n\ntry {\n  const socket = net.createConnection({ host: 'example.com', port: 80 });\n  socket.on('connect', () => console.log('Connected!'));\n} catch (err) {\n  console.error('Permission denied:', err.message);\n}\n\n💡 运行时需添加：\nnode --experimental-permission --allow-net app.js\n\n这类安全控制为 Node CLI 工具、Electron 应用或服务端插件系统提供了新的“沙箱”基础。\n四、Web 标准整合：默认启用 Web Storage\nNode.js 25 正式取消了 --experimental-webstorage 标志，\nWeb Storage（localStorage / sessionStorage）现已默认可用！\n这意味着 Node.js 现在可以像浏览器一样使用本地存储，\n// 示例：Node 中的 localStorage\nlocalStorage.setItem('user', JSON.stringify({ name: 'Developer' }));\nconst user = JSON.parse(localStorage.getItem('user'));\nconsole.log(user); // { name: 'Developer' }\n\nlocalStorage.clear();\n\n对于使用 React Server Components、Next.js、Remix 等框架的开发者来说，\n五、弃用与清理：告别旧时代的 API\nNode.js 25 同时对历史遗留 API 做了重要清理：\n❌ 移除 SlowBuffer（长期弃用）\n❌ 废弃 fs.rmdir(..., { recursive: true }) 的 recursive 选项\nfs.rm(path, { recursive: true })\n🧰 支持便携编译缓存（Portable Compile Cache）\n🔬 WebAssembly 新增 JSPI（JavaScript Plugin Interface）\n同时，内部依赖也迎来更新：\nnpm → 11.6.2\nnghttp3 → 1.11.0\nngtcp2 → 1.14.0（增强 QUIC 协议支持）\n新增 V8 CPU 分析与 QUIC 测试服务器工具\n六、Node.js 25 的意义：从“服务端”走向“通用执行平台”\n如果说 v18~v20 是“稳定性时代”，\n\n演进方向具体体现\n\n性能现代化V8 14.1 + 编译缓存 + JIT 优化\n安全默认化权限模型 + 沙箱机制\nWeb 标准化Web Storage、ErrorEvent 全局可用\n跨环境一致性SSR、CLI、Wasm 都可共享 API\n\n这一切，让 Node.js 不再只是“后端的 JS”，\n可在浏览器、服务端、边缘计算中无缝运行的通用平台。\n七、升级建议\nv25 属于 Current（实验）版本，不建议立即用于生产环境\n适合探索新特性、验证兼容性、提前适配 v26 LTS\n重点关注代码中使用的：\n\nfs.rmdir、SlowBuffer\n自定义权限模型（--allow-*）\nBase64/Hex 编码逻辑\n对 CLI / SSR / AI 推理类项目建议创建独立分支进行试用\n八、结语：更“Web”的 Node，更强的生态未来\nNode.js 25 的每一次改动都在回应一个趋势：\n前端与后端的边界，正在消失。\n当你可以在同一份代码中同时使用 fetch、localStorage、Permission API、Uint8Array 编码、甚至 Wasm 插件时，\n下一代 Web Runtime 的重要一环。\n中文文档刚上线，如果发现文档中有什么问题，欢迎指出，一定及时更新， 希望可以方便更多小伙伴。\n1024 程序员节日快乐，无BUG，祝大家都能早早下班！\n我这边也有一些Node Nest.js 技术交流交流群，感兴趣的可以加我的私人微信 ikoala520  进群，一起学习，共同进步。",
      "hotIndex": 13,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7564227311509979176",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "一个前端工程师的年度作品：从零开发媲美商业级应用的后台管理系统 | 掘金一周 10.23",
      "url": "https://juejin.cn/post/7564227311509979176",
      "pubDate": "Thu, 23 Oct 2025 08:22:00 GMT",
      "description": "本文字数1800+ ，阅读时间大约需要 6分钟。\n【掘金一周】本期亮点：\n一个前端工程师的年度作品：从零开发媲美商业级应用的后台管理系统！\nVue3 登录页还能这么丝滑？这个 hover 效果太惊艳了\n你打的日志，正在拖垮你的系统：从P4小白到P7专家都是怎么打日志的？\n线程池ThreadPoolExecutor源码深度解析｜得物技术\n穿越二十年：Android Native 内存泄漏检测的进化之路\nFlutter 在 iOS 26 模拟器跑不起来？其实很简单\n谈谈上下文工程（Context Engineering）\n90% 代码由 AI 产出，我如何构建可靠上下文体系\n「上榜规则」：文章发布时间在本期「掘金一周」发布时间的前一周内；且符合各个栏目的内容定位和要求。 如发现文章有抄袭、洗稿等违反社区规则的行为，将取消当期及后续上榜资格。\n一周“金”选\n\n内容评审们会在过去的一周内对社区深度技术好文进行挖掘和筛选，优质的技术文章有机会出现在下方榜单中，排名不分先后。\n前端\n一个前端工程师的年度作品：从零开发媲美商业级应用的后台管理系统！ @琢磨先生TT\nArt Design Pro 是一款基于 Vue 3 + TypeScript + Vite + Element Plus 打造的现代化后台管理系统模板。\n它的核心理念是：让后台系统兼具设计美学与开发效率。\nVue3 登录页还能这么丝滑？这个 hover 效果太惊艳了 @刘大华\n这篇文章一步步实现了一个高颜值、强交互的 Vue3 登录页，涵盖了：Vue3 Composition API 使用、动态样式绑定、鼠标事件监听、CSS3 动画与过渡、毛玻璃（backdrop-filter）特效、渐变背景与视觉动效\n打造高性能二维图纸渲染引擎系列（一）：Batched Geometry 助你轻松渲染百万实体  @站好了\n通过 Batched Geometry，我们可以将成千上万次的绘制调用压缩为极少数一次 —— 这正是让基于 Web 的 CAD 浏览体验从 <1 FPS 提升到流畅的 60+ FPS 的核心所在。\n打造高性能二维图纸渲染引擎系列（三）：高性能 CAD 文本渲染背后的隐藏工程 @站好了\n在 cad-viewer 中，我们采用简单且可靠的渐进式渲染模式：使用 setTimeout 安排几何转换工作，并让转换函数是 async，这样它会 await 每个实体的异步 draw() 调用。\n前端技巧：检测到省略号文本自动显示 Tooltip  @代码小学僧\n我们实现了一个自定义 Hook，该 Hook 会监测文本元素是否因宽度限制而被省略。一旦检测到文本内容被省略，Hook 会自动为该元素添加 Tooltip，确保用户可以方便地查看完整信息。\n后端\n你打的日志，正在拖垮你的系统：从P4小白到P7专家都是怎么打日志的？  @大厂码农老A\n一个成熟的日志系统，不应该仅仅是记录信息的工具，而应该是整个系统可观测性的一个核心支柱。应该像一台精密的仪器，静静地运行，却能在关键时刻提供最有力的支持。\n线程池ThreadPoolExecutor源码深度解析｜得物技术 @得物技术\n线程池是Java并发编程的核心组件，通过复用线程减少资源开销，提升系统吞吐量。其核心设计包括线程复用机制 、任务队列和拒绝策略 ，通过ThreadPoolExecutor的参数（核心线程数、最大线程数、队列容量等）实现灵活的资源控制。\n一次慢接口背后，竟藏着40+种可能！你中过几个  @uzong\n本文系统梳理了导致接口响应缓慢的40余种潜在原因，涵盖网络、网关、JVM、数据库、中间件等多个层面，旨在帮助开发者建立完整的性能问题排查思维模型，适用于线上故障定位与技术面试准备\n从被动救火到主动预警，接入 Prometheus + Grafana 全流程  @洛卡卡了 \nPrometheus 不去“监听”，而是主动“拉取”；\n它通过探针（Exporter）定时访问各个服务的监控接口来获取指标数据。\n揭秘ChatGPT“打字机”效果：深入理解SSE流式传输技术  @37手游后端团队\nSSE全称为Server-Sent Events，是服务器主动向客户端推送事件或者说数据流。但它并非一个全新的的协议，是构建在标准的HTTP/1.1协议上的。\nAndroid\n穿越二十年：Android Native 内存泄漏检测的进化之路  @芦半山\nAndroid Native（C/C++）的内存泄漏检测方案从未停下脚步，从最早的Valgrind，到LLVM Sanitizer里的LSan（Leak Sanitizer），再到Android平台的libmemunreachable，每一个阶段都代表着工程师们在性能、准确性与可用性之间的取舍。\nIOS\nFlutter 在 iOS 26 模拟器跑不起来？其实很简单 @恋猫de小郭\n这是 iOS 26 模拟器和 Flutter 的适配问题吗？其实问题确实是适配导致，但是却不是 Flutter 的问题，而是一些插件和模拟器之间的适配问题，实际上问题是：\n用的插件不支持 “ARM 模拟器”，而你默认使用的 iOS 26 模拟器只支持 ARM 。\n人工智能\n谈谈上下文工程（Context Engineering）  @周末程序猿\n大模型发展这两年，应用型 AI 的焦点一直在 “提示工程”（prompt engineering），但随着更强大的大语言模型（LLM）走向多轮、长时间的自主行动，一个更关键的概念开始走到台前：上下文工程（context engineering）。\n90% 代码由 AI 产出，我如何构建可靠上下文体系  @Vadaski\n这也是我为什么会做工程级别的 Context Engineering 的原因：把长期知识（架构/职责/规范）沉到“工程树”，每次按任务打包“顶层规则 + 模块 README（索引） + 任务 spec”的最小集，让模型在清晰边界内工作。\n🚀 程序员必看让AI编程100%可控！从1到N的开发神器OpenSpec规范驱动开发完整实战指南！支持Cursor、Claude Code、Codex！  @win4r\n你有没有遇到过这种情况？满怀期待地让AI助手写代码，结果它理解错了需求，写了一堆你不想要的功能；或者你想让它改个小地方，结果它把整个文件都改乱了；又或者几轮对话后，AI完全忘了你最初想要什么，代码越改越偏...\n📖 投稿专区\n大家可以在评论区推荐认为不错的文章，并附上链接和推荐理由，有机会呈现在下一期。文章创建日期必须在下期掘金一周发布前一周以内；可以推荐自己的文章、也可以推荐他人的文章。",
      "hotIndex": 14,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7564307224266211343",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "神级JS API，谁用谁好用",
      "url": "https://juejin.cn/post/7564307224266211343",
      "pubDate": "Thu, 23 Oct 2025 07:12:47 GMT",
      "description": "前端圈一年 365 天，天天出新框架，但真正能让你少写代码、少引依赖、少踩性能坑的，其实是浏览器爸爸早已偷偷内置的「原生外挂」。\n1. ResizeObserver\nResizeObserver 是一个浏览器原生的 JavaScript API，用于监听 DOM 元素尺寸的变化。它类似于 MutationObserver，但专门用于观察元素的大小（宽高）变化，而无需依赖 window.resize 事件（后者只对视口变化有效）。\n🧩 基本用法\nconst resizeObserver = new ResizeObserver(entries => {\n  for (let entry of entries) {\n    const { width, height } = entry.contentRect;\n    console.log(`元素尺寸：${width} x ${height}`);\n    \n    // entry.target 是被观察的 DOM 元素\n    console.log('目标元素:', entry.target);\n  }\n});\n\n// 开始观察某个元素\nresizeObserver.observe(document.querySelector('#my-element'));\n\n// 可选：观察多个元素\n// resizeObserver.observe(element1);\n// resizeObserver.observe(element2);\n\n📦 entry.contentRect vs getBoundingClientRect()\nentry.contentRect：表示内容区域（不包括 padding、border、margin），类似于 getComputedStyle().width/height 的计算结果。\n如果你需要包括 border 和 padding 的尺寸，可以结合 entry.target.getBoundingClientRect() 使用。\n🛑 停止观察\n// 停止观察某个元素\nresizeObserver.unobserve(element);\n\n// 停止观察所有元素并释放资源\nresizeObserver.disconnect();\n\n建议：在组件销毁（如 React 的 useEffect 清理函数、Vue 的 onBeforeUnmount）时调用 disconnect()，避免内存泄漏。\n✅ 使用场景\n响应式组件：当容器尺寸变化时动态调整子元素（如图表、Canvas、视频）。\n自定义滚动条或布局：监听内容区域变化以更新 UI。\n替代 window.onresize：更精确地响应特定元素的尺寸变化，而非整个窗口。\nWeb Components / 封装组件：内部自动适配父容器大小。\n🌐 浏览器兼容性\n✅ Chrome 64+\n✅ Firefox 69+\n✅ Safari 13.1+\n✅ Edge 79+\n❌ IE 不支持（需 polyfill）\n兼容性已非常广泛，现代项目可放心使用。\n🛠️ Polyfill（如需支持旧浏览器）\n可通过 GitHub - juggle/resize-observer 提供的 polyfill：\nnpm install @juggle/resize-observer\n\nimport ResizeObserver from '@juggle/resize-observer';\n\n// 如果原生不支持，则使用 polyfill\nif (!window.ResizeObserver) {\n  window.ResizeObserver = ResizeObserver;\n}\n\n示例：React 中使用\nimport { useEffect, useRef } from 'react';\n\nfunction MyComponent() {\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const observer = new ResizeObserver(entries => {\n      for (let entry of entries) {\n        console.log('新宽度:', entry.contentRect.width);\n      }\n    });\n\n    if (containerRef.current) {\n      observer.observe(containerRef.current);\n    }\n\n    return () => {\n      observer.disconnect(); // 清理\n    };\n  }, []);\n\n  return <div ref={containerRef}>可变尺寸容器</div>;\n}\n\n2.IntersectionObserver\nIntersectionObserver 是一个强大的浏览器原生 API，用于异步监听目标元素与祖先元素（或视口）的交叉（相交）状态变化。它常用于实现懒加载、无限滚动、曝光统计、动画触发等场景，性能远优于传统的 scroll 事件监听。\n🧩 基本用法\nconst observer = new IntersectionObserver((entries, observer) => {\n  entries.forEach(entry => {\n    // entry.target：被观察的 DOM 元素\n    // entry.isIntersecting：是否与根（viewport 或 root）相交\n    // entry.intersectionRatio：相交区域占目标元素的比例（0 ~ 1）\n    // entry.intersectionRect：相交区域的矩形信息\n    // entry.boundingClientRect：目标元素相对于视口的位置\n    // entry.rootBounds：根元素的边界（通常是视口）\n\n    if (entry.isIntersecting) {\n      console.log('元素进入视口:', entry.target);\n      // 例如：加载图片、触发动画\n    } else {\n      console.log('元素离开视口');\n    }\n  });\n});\n\n// 开始观察某个元素\nobserver.observe(document.querySelector('#my-element'));\n\n⚙️ 配置选项（可选）\nconst options = {\n  root: null, // 默认为视口（viewport）；可设为某个祖先元素\n  rootMargin: '0px', // 类似 CSS margin，扩展或收缩根的边界（支持负值）\n  threshold: 0.5 // 触发回调的相交比例阈值（0 ~ 1），可为数字或数组\n};\n\nconst observer = new IntersectionObserver(callback, options);\n\nthreshold 示例：\nthreshold: 0：只要有一点进入就触发（默认）。\nthreshold: 1：完全进入才触发。\nthreshold: [0, 0.25, 0.5, 0.75, 1]：在 0%、25%、50%... 时都触发。\n🛑 停止观察\njavascript\n编辑\nobserver.unobserve(element); // 停止单个元素\nobserver.disconnect();      // 停止所有并释放资源\n\n建议：在组件销毁时调用 disconnect()，防止内存泄漏。\n✅ 典型应用场景\n1. 图片懒加载\nconst imgObserver = new IntersectionObserver((entries) => {\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      const img = entry.target;\n      img.src = img.dataset.src; // 从 data-src 加载真实图片\n      imgObserver.unobserve(img); // 加载后停止观察\n    }\n  });\n});\n\ndocument.querySelectorAll('img[data-src]').forEach(img => {\n  imgObserver.observe(img);\n});\n\n2. 滚动到底部自动加载（无限滚动）\n观察一个“哨兵”元素（如分页加载提示），当它进入视口时触发加载。\n3. 曝光埋点 / 广告可见性统计\n当广告或内容区域进入视口一定比例时，上报“曝光”事件。\n4. 滚动动画（如 AOS 效果）\n元素进入视口时添加 CSS 动画类。\n🌐 浏览器兼容性\n✅ Chrome 51+\n✅ Firefox 55+\n✅ Safari 12.1+\n✅ Edge 15+\n❌ IE 不支持（需 polyfill）\n现代浏览器支持良好，移动端也广泛可用。\n🛠️ Polyfill（兼容旧浏览器）\n官方推荐 polyfill（由 W3C 团队维护）：\nnpm install intersection-observer\n\n// 在应用入口引入（自动填充 window.IntersectionObserver）\nimport 'intersection-observer';\n\n注意：polyfill 会回退到 scroll + getBoundingClientRect()，性能较差，仅用于兼容。\n💡 与 ResizeObserver / MutationObserver 对比\n\nAPI用途\n\nIntersectionObserver监听元素是否进入/离开视口（或指定容器）\nResizeObserver监听元素尺寸变化\nMutationObserver监听 DOM 结构或属性变化\n\n三者互补，常结合使用。\n📌 小技巧\n使用 rootMargin: '100px' 可以提前触发（在元素距离视口还有 100px 时就加载）。\n在 <img loading=\"lazy\"> 普及的今天，简单图片懒加载可直接用 HTML 属性，但复杂逻辑仍需 IntersectionObserver。\n3.Page Visibility\nPage Visibility API 是一个浏览器原生 API，用于检测当前网页是否对用户可见（即是否处于前台标签页或被最小化/切换到后台）。它可以帮助开发者优化性能、节省资源，或实现特定业务逻辑（如暂停视频、停止轮询、统计停留时长等）。\n🧩 核心属性与事件\n1. document.visibilityState\n返回当前页面的可见性状态，可能值包括：\n\n值含义\n\n'visible'页面可见（处于前台标签页）\n'hidden'页面不可见（切换到其他标签页、最小化窗口、锁屏等）\n'prerender'页面正在预渲染（已废弃，现代浏览器基本不用）\n'unloaded'页面即将卸载（极少使用）\n\n实际开发中主要关注 'visible' 和 'hidden'。\n2. document.hidden（已废弃，建议用 visibilityState）\ntrue：页面不可见\nfalse：页面可见\n⚠️ 虽仍可用，但 MDN 建议使用 visibilityState。\n3. visibilitychange 事件\n当页面可见性状态改变时触发。\n✅ 基本用法示例\nfunction handleVisibilityChange() {\n  if (document.visibilityState === 'visible') {\n    console.log('页面回到前台');\n    // 恢复视频播放、重启定时器、刷新数据等\n  } else if (document.visibilityState === 'hidden') {\n    console.log('页面进入后台');\n    // 暂停视频、停止轮询、保存状态等\n  }\n}\n\n// 监听可见性变化\ndocument.addEventListener('visibilitychange', handleVisibilityChange);\n\n🌟 典型应用场景\n1. 暂停/恢复媒体播放\nconst video = document.querySelector('video');\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) {\n    video.pause();\n  } else {\n    video.play();\n  }\n});\n\n2. 停止不必要的轮询或定时任务\nlet intervalId;\n\nfunction startPolling() {\n  intervalId = setInterval(fetchData, 5000);\n}\n\nfunction stopPolling() {\n  clearInterval(intervalId);\n}\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) {\n    stopPolling();\n  } else {\n    startPolling();\n  }\n});\n\nstartPolling(); // 初始启动\n\n3. 用户停留时长统计\nlet startTime = Date.now();\nlet totalVisibleTime = 0;\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) {\n    totalVisibleTime += Date.now() - startTime;\n  } else {\n    startTime = Date.now();\n  }\n});\n\n// 页面卸载时上报总可见时长\nwindow.addEventListener('beforeunload', () => {\n  totalVisibleTime += Date.now() - startTime;\n  sendToAnalytics({ visibleTime: totalVisibleTime });\n});\n\n4. 节省资源（如 Canvas 动画、WebGL）\n在页面不可见时暂停渲染循环，减少 CPU/GPU 消耗。\n🌐 浏览器兼容性\n✅ Chrome 13+\n✅ Firefox 10+\n✅ Safari 7+\n✅ Edge 12+\n✅ iOS Safari / Android Browser（现代版本）\n兼容性极佳，几乎所有现代浏览器都支持。\n⚠️ 注意事项\n不保证精确性：在某些系统（如 macOS 快速切换）中，状态切换可能有微小延迟。\n不是用户活跃度检测：页面可见 ≠ 用户正在看（用户可能切到其他应用但浏览器窗口仍在前台）。\n与 blur/focus 事件的区别：\nwindow.onfocus / window.onblur：监听窗口焦点（如切换到其他应用）。\nvisibilitychange：监听标签页是否可见（即使窗口有焦点，但标签页在后台也算 hidden）。\n两者可结合使用以获得更全面的状态判断。\n🔍 扩展：结合 focus/blur 更精准判断\nlet isPageVisible = !document.hidden;\nlet isWindowFocused = !document.hasFocus();\n\nwindow.addEventListener('focus', () => {\n  isWindowFocused = true;\n  if (isPageVisible) {\n    console.log('用户很可能正在看页面');\n  }\n});\n\nwindow.addEventListener('blur', () => {\n  isWindowFocused = false;\n});\n\ndocument.addEventListener('visibilitychange', () => {\n  isPageVisible = !document.hidden;\n});\n\n4.Web Share API\nWeb Share API 是一个现代浏览器提供的原生 API，允许网页调用操作系统级别的分享功能，让用户将内容（如链接、文本、标题等）快速分享到设备上安装的其他应用（如微信、邮件、短信、笔记等）。\n✅ 基本用法\nif (navigator.share) {\n  navigator.share({\n    title: '分享标题',\n    text: '分享的描述文字',\n    url: 'https://example.com'\n  })\n  .then(() => {\n    console.log('分享成功');\n  })\n  .catch((error) => {\n    if (error.name === 'AbortError') {\n      console.log('用户取消了分享');\n    } else {\n      console.error('分享失败:', error);\n    }\n  });\n} else {\n  // 回退方案：显示自定义分享按钮或提示\n  alert('您的浏览器不支持 Web Share API，请手动复制链接');\n}\n\n⚠️ 必须在用户手势触发的上下文中调用（如点击事件），否则会抛出安全错误。\n🔐 安全与限制\n仅限安全上下文：必须在 HTTPS（或 localhost）下使用。\n用户手势要求：只能在 click、touchend 等用户操作回调中调用。\n字段非全部必需：但至少要提供 title、text、url 中的一个（推荐提供 url）。\n无法控制目标应用：分享目标由操作系统决定，开发者无法指定（如“只分享到微信”）。\n📱 支持情况（截至 2025 年）\n\n平台浏览器支持情况\n\nAndroidChrome 61+✅ 完整支持\niOSSafari 12.2+✅（需 iOS 12.2+）\nWindowsChrome 76+ / Edge 79+✅（调用系统分享面板）\nmacOSSafari 13+ / Chrome✅（部分版本）\nLinux部分浏览器⚠️ 有限支持\n\n可通过 caniuse.com/web-share 查看最新兼容性。\n🧩 高级用法：分享文件（Web Share API Level 2）\n现代浏览器（Chrome 89+ 等）支持分享文件（如图片、PDF）：\nif (navigator.canShare && navigator.canShare({ files: [file] })) {\n  await navigator.share({\n    title: '图片分享',\n    files: [file] // File 对象数组\n  });\n}\n\n注意：文件必须来自用户选择（如 <input type=\"file\">）或由网页生成，不能是任意网络文件。\n🔄 回退方案（Fallback）\n当不支持 Web Share 时，可提供复制链接或自定义分享按钮：\nfunction fallbackShare(url) {\n  const input = document.createElement('input');\n  input.value = url;\n  document.body.appendChild(input);\n  input.select();\n  document.execCommand('copy');\n  document.body.removeChild(input);\n  alert('链接已复制到剪贴板');\n}\n\n📦 在框架中使用（React 示例）\nfunction ShareButton({ url, title, text }) {\n  const handleShare = async () => {\n    if (navigator.share) {\n      try {\n        await navigator.share({ url, title, text });\n      } catch (err) {\n        console.warn('分享被取消或失败', err);\n      }\n    } else {\n      fallbackShare(url);\n    }\n  };\n\n  return (\n    <button onClick={handleShare}>\n      分享\n    </button>\n  );\n}\n\n🚀 优势\n原生体验：使用系统分享面板，用户熟悉且支持所有已安装应用。\n无需第三方 SDK：避免集成微信、微博等 SDK 的复杂性。\n隐私友好：不收集用户分享行为数据（除非你自己上报）。\n📌 小贴士\n测试时可在 Chrome DevTools 的 Device Mode（设备模拟）  中查看分享弹窗。\n在 PWA 中使用效果最佳，可实现“类原生”分享体验。\n5. Wake Lock\nWake Lock API 是一个现代 Web API，允许网页防止设备进入休眠状态（如屏幕变暗、锁屏），常用于需要长时间保持活跃的场景，例如：\n视频播放器（避免播放时屏幕关闭）\n导航应用（持续显示路线）\n扫码/AR 应用（保持摄像头活跃）\n阅读器/电子书（长时间阅读不锁屏）\n🔒 两种锁类型（目前主要支持 screen）\n// 1. Screen Wake Lock（屏幕唤醒锁） ← 当前唯一广泛支持的类型\n// 2. System Wake Lock（系统唤醒锁） ← 尚未标准化，基本不可用\n\n目前 只有 screen 类型 在主流浏览器中可用。\n✅ 基本用法（Screen Wake Lock）\nlet wakeLock = null;\n\nasync function requestWakeLock() {\n  try {\n    // 请求屏幕唤醒锁\n    wakeLock = await navigator.wakeLock.request('screen');\n    console.log('Wake Lock 已激活');\n\n    // 监听释放事件（如页面隐藏、用户锁屏）\n    wakeLock.addEventListener('release', () => {\n      console.log('Wake Lock 已释放');\n    });\n\n  } catch (err) {\n    console.error('Wake Lock 请求失败:', err);\n  }\n}\n\n// 在用户交互后调用（如点击按钮）\ndocument.getElementById('keepAwakeBtn').addEventListener('click', requestWakeLock);\n\n⚠️ 必须由用户手势触发（如 click），不能在页面加载时自动请求。\n🛑 释放锁（可选，通常自动释放）\nif (wakeLock) {\n  await wakeLock.release(); // 显式释放\n  wakeLock = null;\n}\n\n锁会在以下情况自动释放：\n页面进入后台（visibilitychange → hidden）\n浏览器标签页关闭\n用户手动锁屏\n页面失去焦点（部分浏览器）\n🌐 浏览器兼容性（截至 2025 年）\n\n浏览器支持情况\n\nChrome✅ 84+（Android & Desktop）\nEdge✅ 84+\nSafari❌ 不支持（iOS/macOS 均未实现）\nFirefox❌ 默认禁用（需手动开启 dom.wakelock.enabled）\n\n移动端 Chrome（Android）支持最好，iOS Safari 完全不支持。\n可通过 caniuse.com/wake-lock 查看最新状态。\n🛡️ 安全与权限要求\n必须在 HTTPS 下使用（localhost 除外）\n必须由用户手势触发（如点击、触摸）\n仅在页面可见时有效（页面切到后台会自动释放）\n不会绕过系统锁屏密码，仅防止屏幕变暗/休眠\n💡 实际应用场景示例\n场景：视频播放时不锁屏\nconst video = document.querySelector('video');\n\nvideo.addEventListener('play', async () => {\n  if ('wakeLock' in navigator) {\n    try {\n      wakeLock = await navigator.wakeLock.request('screen');\n    } catch (err) {\n      console.warn('无法保持屏幕常亮:', err);\n    }\n  }\n});\n\nvideo.addEventListener('pause', () => {\n  if (wakeLock) wakeLock.release();\n});\n\n场景：结合 Page Visibility 自动管理\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden && wakeLock) {\n    wakeLock.release(); // 页面隐藏时主动释放\n  }\n});\n\n🔄 降级方案（Fallback）\n在不支持 Wake Lock 的环境（如 iOS）：\n提示用户“请手动关闭自动锁屏”\n使用全屏 API（requestFullscreen()）有时可延长屏幕活跃时间（非可靠）\n对于视频，可尝试使用 <video playsinline webkit-playsinline> 等属性优化体验\n📌 注意事项\n不要滥用：长时间保持唤醒会显著增加耗电。\n始终提供关闭选项：让用户能手动禁用“保持唤醒”。\n测试真实设备：模拟器行为可能与真机不同。\n🔍 检测是否支持\nif ('wakeLock' in navigator) {\n  // 支持 Wake Lock API\n}\n\n6. Broadcast Channel\nBroadcastChannel 是一个现代 Web API，允许同源（same-origin）的不同浏览器上下文（如多个标签页、iframe、Web Worker）之间进行简单、高效的跨文档通信。\n它类似于“发布-订阅”模式：一个上下文发送消息，所有监听同一频道的其他上下文都能收到。\n🧩 基本用法\n1. 创建频道并监听消息\n// 所有页面/worker 使用相同的频道名\nconst channel = new BroadcastChannel('my-app-channel');\n\n// 监听来自其他上下文的消息\nchannel.addEventListener('message', (event) => {\n  console.log('收到消息:', event.data);\n});\n\n// 或使用 onmessage\n// channel.onmessage = (event) => { ... };\n\n2. 发送消息\n// 任意同源页面或 worker 中\nchannel.postMessage({ type: 'USER_LOGIN', userId: 123 });\n\n3. 关闭频道（可选，推荐在页面卸载时调用）\nwindow.addEventListener('beforeunload', () => {\n  channel.close(); // 释放资源\n});\n\n✅ 自动广播：消息会发送给所有监听 'my-app-channel' 的同源上下文（包括发送者自己，除非你过滤）。\n🔐 安全限制\n同源策略：只有协议 + 域名 + 端口完全相同的页面才能通信。\nhttps://example.com/page1 和 https://example.com/page2 ✅\nhttps://example.com 和 https://sub.example.com ❌\nhttp://localhost:3000 和 http://localhost:8080 ❌\n不支持跨域：不能用于跨域 iframe 通信（此时应考虑 postMessage + origin 验证）。\n✅ 典型应用场景\n1. 用户登录/登出同步\n当用户在一个标签页登录，其他标签页自动更新状态：\n// 登录页\nchannel.postMessage({ type: 'AUTH_CHANGED', user: { id: 1, name: 'Alice' } });\n\n// 其他页面\nchannel.onmessage = (e) => {\n  if (e.data.type === 'AUTH_CHANGED') {\n    if (e.data.user) {\n      updateUI(e.data.user); // 显示用户信息\n    } else {\n      logoutAllTabs(); // 用户登出\n    }\n  }\n};\n\n2. 多标签页状态同步\n购物车变更\n主题切换（深色/浅色模式）\n语言切换\n3. 通知其他标签页刷新数据\n例如后台管理页更新后，通知前台页面重新拉取配置。\n4. 与 Web Worker 通信\n主线程和多个 worker 可通过 BroadcastChannel 广播消息。\n🌐 浏览器兼容性（截至 2025 年）\n\n浏览器支持情况\n\nChrome✅ 54+\nEdge✅ 79+\nFirefox✅ 38+\nSafari✅ 15.4+（iOS 15.4+ / macOS Monterey+）\niOS WebView✅ 15.4+\n\n⚠️ Safari 在 15.4 之前完全不支持，如需兼容旧版 iOS，需使用 localStorage + storage 事件作为 fallback。\n🔄 降级方案（Fallback for older browsers）\n利用 localStorage 的 storage 事件实现类似广播：\n// 发送消息（fallback）\nfunction broadcastFallback(message) {\n  localStorage.setItem('broadcast-msg', JSON.stringify({\n    ...message,\n    timestamp: Date.now()\n  }));\n}\n\n// 接收消息（其他标签页会触发 storage 事件）\nwindow.addEventListener('storage', (e) => {\n  if (e.key === 'broadcast-msg') {\n    const message = JSON.parse(e.newValue);\n    console.log('Fallback 收到:', message);\n  }\n});\n\n缺点：只能传递字符串，且 storage 事件不会在当前标签页触发（正好避免自己收到自己发的消息）。\n🆚 与其他通信方式对比\n\n方式适用场景跨域多标签Worker\n\nBroadcastChannel同源多上下文广播❌✅✅\nwindow.postMessage精确点对点通信✅（需验证 origin）✅（需持有 window 引用）✅\nSharedWorker多页面共享逻辑❌✅✅（作为中介）\nlocalStorage + storage简单广播（旧浏览器）❌✅❌\n\n💡 小技巧\n避免无限循环：如果多个页面都响应消息并再次广播，可能形成循环。建议使用 type 字段区分消息来源或添加防重机制。\n结构化克隆：postMessage 支持传输 ArrayBuffer、Blob、Map 等（遵循结构化克隆算法），不只是 JSON。\n📦 在框架中使用（React 示例）\nimport { useEffect } from 'react';\n\nfunction useBroadcastChannel(channelName, onMessage) {\n  useEffect(() => {\n    const channel = new BroadcastChannel(channelName);\n    channel.onmessage = onMessage;\n\n    return () => {\n      channel.close();\n    };\n  }, [channelName, onMessage]);\n}\n\n// 使用\nfunction App() {\n  useBroadcastChannel('theme-channel', (e) => {\n    if (e.data.type === 'THEME_CHANGE') {\n      document.body.className = e.data.theme;\n    }\n  });\n\n  const changeTheme = (theme) => {\n    new BroadcastChannel('theme-channel').postMessage({\n      type: 'THEME_CHANGE',\n      theme\n    });\n  };\n\n  return <button onClick={() => changeTheme('dark')}>切换深色</button>;\n}\n\nBroadcastChannel和 Vuex / Redux\n🔍 核心区别\n\n特性BroadcastChannelVuex / Redux / Zustand 等\n\n作用范围跨浏览器上下文（多个标签页、iframe、Web Worker）单个页面/应用内部（组件之间）\n通信方式跨文档广播（类似“全局事件总线”）单向数据流 + 响应式状态管理\n数据存储❌ 不存储状态，只传递消息✅ 集中式存储状态（store）\n响应式更新❌ 需手动监听消息并更新 UI✅ 状态变化自动触发组件重渲染\n同源限制✅ 仅限同源页面无（仅限当前页面）\n典型用途多标签页登录同步、跨 Worker 通信组件间状态共享、复杂状态逻辑管理\n\n🧩 举个例子说明差异\n场景：用户登录后，所有打开的标签页都要显示用户名\n用 BroadcastChannel：\n标签页 A 登录 → 通过 channel.postMessage({ type: 'LOGIN', user }) 广播。\n标签页 B、C（即使没用 Vue/React）监听到消息 → 各自更新自己的 UI。\n每个页面独立维护自己的状态，只是通过消息“同步”了登录事件。\n用 Vuex：\n只在当前标签页内，多个 Vue 组件共享 store.state.user。\n标签页 A 的 Vuex 无法直接影响标签页 B 的 Vuex。\n如果你打开两个标签页，它们有两个完全独立的 Vuex 实例。\n✅ 所以：Vuex 管“页面内”，BroadcastChannel 管“页面间” 。\n🤝 它们可以结合使用！\n实际项目中，两者常配合使用：\n// 在 Vuex 的 action 中监听 BroadcastChannel\nconst channel = new BroadcastChannel('auth-channel');\n\nconst store = new Vuex.Store({\n  state: { user: null },\n  mutations: {\n    SET_USER(state, user) {\n      state.user = user;\n    }\n  },\n  actions: {\n    login({ commit }, user) {\n      commit('SET_USER', user);\n      // 登录后广播给其他标签页\n      channel.postMessage({ type: 'LOGIN', user });\n    }\n  }\n});\n\n// 监听其他标签页的登录/登出\nchannel.onmessage = (e) => {\n  if (e.data.type === 'LOGIN') {\n    store.commit('SET_USER', e.data.user); // 更新当前页状态\n  } else if (e.data.type === 'LOGOUT') {\n    store.commit('SET_USER', null);\n  }\n};\n\n这样：\n页面内：Vuex 管理状态，组件自动响应。\n页面间：BroadcastChannel 同步关键事件。\n❓那有没有“跨标签页的 Vuex”？\n有！社区有一些库尝试结合两者，例如：\nvuex-shared-mutations：通过 localStorage 或 BroadcastChannel 同步 Vuex 的 mutations。\n自定义方案：监听 storage 事件或 BroadcastChannel，触发本地 store 更新。\n但核心思想不变：跨标签页通信靠 BroadcastChannel（或 storage），状态管理靠 Vuex。\n✅ 总结\n\n你想做……该用……\n\n组件之间共享状态、触发更新Vuex / Redux / Context / Zustand\n多个浏览器标签页同步登录状态BroadcastChannel（或 localStorage + storage 事件）\n让 Vuex 状态在多标签页同步BroadcastChannel + Vuex 结合\n\n7. PerformanceObserver\nPerformanceObserver 是一个强大的 Web API，用于异步监听性能相关的事件和指标，而无需轮询 performance.getEntries()。它是现代 Web 性能监控（如 Core Web Vitals）的核心工具。\n🎯 核心作用\n监听浏览器自动记录的 Performance Timeline（性能时间线） 中的新条目，例如：\n资源加载（resource）\n导航 timing（navigation）\n长任务（longtask）\n元素曝光（element，实验性）\n最重要：  CLS、LCP、FCP、INP 等 Web Vitals 指标\n🧩 基本用法\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    console.log(entry.name, entry.entryType, entry.startTime, entry.duration);\n  }\n});\n\n// 开始监听特定类型的性能条目\nobserver.observe({ entryTypes: ['resource', 'navigation', 'paint'] });\n\n⚠️ 必须指定 entryTypes（或 type），否则不会触发回调。\n🔍 常见 entryTypes 及用途\n\nentryType说明典型用途\n\n'navigation'页面导航性能（如 DNS、TCP、DOMContentLoaded）分析首屏加载瓶颈\n'resource'所有资源加载（JS、CSS、图片、XHR、fetch）监控第三方资源、慢请求\n'paint'首次绘制（FP）、首次内容绘制（FCP）衡量视觉加载速度\n'longtask'超过 50ms 的主线程任务识别卡顿、影响交互响应的原因\n'largest-contentful-paint' (LCP)最大内容元素渲染时间核心 Web Vitals 指标\n'layout-shift' (CLS)累积布局偏移检测页面“抖动”\n'first-input' (FID) / 'event' (INP)首次输入延迟 / 交互到下次绘制衡量交互响应性\n\n✅ LCP、CLS、INP 等现代指标必须通过 PerformanceObserver 获取，无法通过 getEntries() 静态读取。\n✅ 实战示例\n1. 监听 LCP（最大内容绘制）\nlet lcpReported = false;\n\nnew PerformanceObserver((entryList) => {\n  const lcpEntry = entryList.getEntries().at(-1); // 取最后一个（最准确）\n  if (!lcpReported) {\n    console.log('LCP:', lcpEntry.startTime); // 单位：毫秒\n    // 上报到分析平台\n    sendToAnalytics({ metric: 'LCP', value: lcpEntry.startTime });\n    lcpReported = true;\n  }\n}).observe({ type: 'largest-contentful-paint', buffered: true });\n\nbuffered: true 表示获取已发生但未被观察到的历史条目（对 LCP/CLS 必须加！）。\n2. 监听 CLS（累积布局偏移）\nlet clsValue = 0;\n\nnew PerformanceObserver((entryList) => {\n  for (const entry of entryList.getEntries()) {\n    if (!entry.hadRecentInput) { // 忽略用户交互后的偏移\n      clsValue += entry.value;\n    }\n  }\n  console.log('当前 CLS:', clsValue);\n}).observe({ type: 'layout-shift', buffered: true });\n\n3. 监控慢资源加载\nnew PerformanceObserver((list) => {\n  for (const resource of list.getEntries()) {\n    if (resource.duration > 2000) {\n      console.warn('慢资源:', resource.name, resource.duration + 'ms');\n      // 上报性能问题\n    }\n  }\n}).observe({ entryTypes: ['resource'] });\n\n4. 捕获长任务（卡顿原因）\nnew PerformanceObserver((list) => {\n  for (const task of list.getEntries()) {\n    if (task.duration > 100) {\n      console.log('长任务:', task.duration + 'ms', task.attribution);\n    }\n  }\n}).observe({ entryTypes: ['longtask'] });\n\n需要先注册长任务支持（部分浏览器需 polyfill）：\nif (PerformanceObserver.supportedEntryTypes.includes('longtask')) {\n  // 启用观察\n}\n\n🌐 浏览器兼容性\n✅ Chrome / Edge：全面支持（包括 Web Vitals）\n✅ Firefox：支持基础类型（resource, navigation），Web Vitals 支持较弱\n✅ Safari 15+：支持 LCP、CLS、FCP 等核心指标\n❌ IE：不支持\n推荐使用 Google 的 web-vitals 库 跨浏览器采集 Core Web Vitals。\n📦 与 performance.getEntries() 对比\n\n方式优点缺点\n\nPerformanceObserver异步、实时、支持 Web Vitals、不阻塞主线程需要提前注册监听\nperformance.getEntries()简单直接、可查询历史无法获取动态指标（如 LCP 在发生时才能确定）、需轮询\n\n✅ 现代性能监控应优先使用 PerformanceObserver。\n🚀 最佳实践\n尽早注册：在 <head> 中或页面顶部初始化，避免漏掉早期指标。\n使用 buffered: true：确保捕获 FCP、LCP、CLS 等可能在监听前已发生的指标。\n避免内存泄漏：通常不需要 disconnect()，因为性能条目是一次性的。\n结合 RUM（真实用户监控） ：将数据上报到分析平台（如 GA4、Sentry、自建服务）。\n🛠️ 工具推荐\nweb-vitals npm 包：Google 官方封装，一行代码获取 Web Vitals。\nimport { getLCP, getCLS, getFCP } from 'web-vitals';\ngetLCP(console.log);\n\nReact（使用 Hook） 和 Vue 3（使用 Composition API）\n✅ 共同前提\n我们使用 Google 官方的 web-vitals 库，它已封装好 PerformanceObserver 的兼容逻辑。\nnpm install web-vitals\n\n🟦 React 版本：useWebVitals\n// hooks/useWebVitals.ts\nimport { useEffect } from 'react';\nimport { getCLS, getFCP, getLCP, getFID, getINP } from 'web-vitals';\n\ntype WebVitalsMetric = {\n  id: string;\n  name: string;\n  value: number;\n  delta: number;\n  entries: PerformanceEntry[];\n  attribution: Record<string, unknown>;\n};\n\ntype WebVitalsOptions = {\n  onReport?: (metric: WebVitalsMetric) => void;\n  reportAll?: boolean; // 是否上报所有指标（默认只上报一次）\n};\n\nexport const useWebVitals = ({\n  onReport,\n  reportAll = false\n}: WebVitalsOptions = {}) => {\n  useEffect(() => {\n    // 定义上报函数\n    const report = (metric: WebVitalsMetric) => {\n      onReport?.(metric);\n      if (process.env.NODE_ENV === 'development') {\n        console.log('Web Vitals:', metric);\n      }\n    };\n\n    // 启动监听（Web Vitals 内部使用 PerformanceObserver）\n    getCLS(report, reportAll);\n    getFCP(report, reportAll);\n    getLCP(report, reportAll);\n    getFID(report); // FID 只触发一次\n    getINP(report, reportAll); // INP 替代 FID（未来标准）\n\n    // 注意：web-vitals 的指标是自动管理生命周期的，无需 cleanup\n  }, [onReport, reportAll]);\n};\n\n📌 使用示例\n// App.tsx\nimport { useWebVitals } from './hooks/useWebVitals';\n\nfunction App() {\n  useWebVitals({\n    onReport: (metric) => {\n      // 上报到分析平台（如 GA4、Sentry、自建 API）\n      fetch('/api/performance', {\n        method: 'POST',\n        body: JSON.stringify(metric),\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n  });\n\n  return <div>你的应用</div>;\n}\n\n✅ 优点：自动处理浏览器兼容性、只上报有效指标、支持开发环境日志。\n🟩 Vue 3 版本：useWebVitals\n// composables/useWebVitals.ts\nimport { onMounted } from 'vue';\nimport { getCLS, getFCP, getLCP, getFID, getINP } from 'web-vitals';\n\ntype WebVitalsMetric = {\n  id: string;\n  name: string;\n  value: number;\n  delta: number;\n  entries: PerformanceEntry[];\n  attribution: Record<string, unknown>;\n};\n\nexport function useWebVitals(\n  onReport?: (metric: WebVitalsMetric) => void,\n  reportAll = false\n) {\n  onMounted(() => {\n    const report = (metric: WebVitalsMetric) => {\n      onReport?.(metric);\n      if (import.meta.env.DEV) {\n        console.log('Web Vitals:', metric);\n      }\n    };\n\n    getCLS(report, reportAll);\n    getFCP(report, reportAll);\n    getLCP(report, reportAll);\n    getFID(report);\n    getINP(report, reportAll);\n  });\n}\n\n📌 使用示例\n<!-- App.vue -->\n<script setup>\nimport { useWebVitals } from './composables/useWebVitals';\n\nuseWebVitals((metric) => {\n  fetch('/api/performance', {\n    method: 'POST',\n    body: JSON.stringify(metric),\n    headers: { 'Content-Type': 'application/json' }\n  });\n});\n</script>\n\n<template>\n  <div>你的应用</div>\n</template>\n\n🧩 高级：监控慢资源加载（自定义 PerformanceObserver）\n如果你还想监控 JS/CSS/图片等资源加载性能，可以额外封装一个 Hook：\nReact: useResourcePerformance\n// hooks/useResourcePerformance.ts\nimport { useEffect } from 'react';\n\nexport const useResourcePerformance = (onSlowResource: (entry: PerformanceResourceTiming) => void) => {\n  useEffect(() => {\n    if (!PerformanceObserver.supportedEntryTypes.includes('resource')) return;\n\n    const observer = new PerformanceObserver((list) => {\n      for (const entry of list.getEntries() as PerformanceResourceTiming[]) {\n        if (entry.duration > 2000) {\n          onSlowResource(entry);\n        }\n      }\n    });\n\n    observer.observe({ entryTypes: ['resource'] });\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [onSlowResource]);\n};\n\nVue 版本类似，用 onMounted + onUnmounted 管理生命周期。\n📊 上报建议\nLCP、FCP、CLS：每个页面会话上报一次（reportAll: false）。\nINP/FID：用户每次交互可能触发，可采样上报。\n慢资源：可聚合后批量上报，避免频繁请求。\n🚀 部署提示\n在 生产环境 使用，开发环境仅用于调试。\n避免阻塞主渲染逻辑（web-vitals 是异步非阻塞的）。\n配合 Google Analytics 4 的 Web Vitals 自动采集 更省事。\n8. requestIdleCallback\nrequestIdleCallback 是一个浏览器提供的 API，用于在浏览器主线程空闲时执行低优先级任务，避免影响关键操作（如用户输入、动画、布局等），从而提升页面流畅性和响应性。\n💡 它是实现“协作式调度（Cooperative Scheduling） ”的关键工具，React 16+ 的 Fiber 架构就受其启发（尽管 React 最终未直接使用它）。\n🧩 基本用法\nfunction doLowPriorityWork(deadline) {\n  // deadline.timeRemaining()：返回当前空闲时段还剩多少毫秒（通常 < 50ms）\n  // deadline.didTimeout：是否因超时而强制执行（配合 timeout 使用）\n\n  while (deadline.timeRemaining() > 0 || deadline.didTimeout) {\n    if (hasWork()) {\n      performUnitOfWork();\n    } else {\n      break; // 没有更多工作，退出\n    }\n  }\n\n  // 如果还有剩余任务，继续调度\n  if (hasMoreWork()) {\n    requestIdleCallback(doLowPriorityWork);\n  }\n}\n\n// 启动任务\nrequestIdleCallback(doLowPriorityWork, { timeout: 2000 });\n\n⚙️ 参数说明\n1. 回调函数参数：deadline\ndeadline.timeRemaining()：返回一个估算值（单位：毫秒），表示当前帧剩余的空闲时间（通常 ≤ 50ms）。\ndeadline.didTimeout：如果设置了 timeout 且超时，则为 true，此时应尽快完成任务。\n2. 可选配置对象\n{\n  timeout: 2000 // 最大等待时间（毫秒）。超时后即使没有空闲也会执行回调。\n}\n\n⚠️ timeout 会降低优先级优势，仅用于“最终必须执行”的兜底场景。\n✅ 典型应用场景\n1. 非关键数据预加载\nrequestIdleCallback(() => {\n  // 预加载下一页数据、图片、代码分割 chunk\n  import('./NextPageComponent');\n});\n\n2. 埋点/日志批量上报\nlet logs = [];\n\nfunction sendLogs() {\n  if (logs.length > 0) {\n    navigator.sendBeacon('/log', JSON.stringify(logs));\n    logs = [];\n  }\n}\n\nfunction addLog(event) {\n  logs.push(event);\n  requestIdleCallback(sendLogs, { timeout: 5000 });\n}\n\n3. 大型列表虚拟滚动的缓存计算\n在用户停止滚动后，利用空闲时间预计算可视区域外的 item 尺寸。\n4. 分析用户行为（非实时）\n如统计停留时长、点击热力图聚合等。\n🌐 浏览器兼容性（截至 2025 年）\n\n浏览器支持情况\n\nChrome✅ 47+\nEdge✅ 79+\nFirefox❌ 不支持（已明确拒绝实现）\nSafari❌ 不支持\niOS / Android WebView❌ 基本不可用\n\n🔥 现实：仅 Chrome/Edge 支持，Firefox 和 Safari 永远不会支持！\n可通过 caniuse.com/requestidle… 查看。\n🔄 降级方案（Polyfill / 替代方案）\n由于兼容性差，生产环境必须提供 fallback。\n方案 1：使用 setTimeout 模拟（简单但不精确）\nconst requestIdleCallback =\n  window.requestIdleCallback ||\n  function (callback) {\n    const start = Date.now();\n    return setTimeout(() => {\n      callback({\n        didTimeout: false,\n        timeRemaining: () => Math.max(0, 50 - (Date.now() - start))\n      });\n    }, 1);\n  };\n\nconst cancelIdleCallback =\n  window.cancelIdleCallback ||\n  function (id) {\n    clearTimeout(id);\n  };\n\n方案 2：使用 requestAnimationFrame + 时间切片（更接近原生行为）\n适用于需要精细控制的任务调度（如 React Fiber 的思路）。\n方案 3：直接使用 setTimeout(fn, 0) 或 queueMicrotask\n适用于非关键但需异步执行的任务，但无法利用“空闲时间”。\n⚠️ 注意事项\n不要执行高优先级任务：如用户输入响应、动画更新。\n避免长时间运行：即使 timeRemaining() 返回较大值，也应分片处理。\n不要依赖精确时间：timeRemaining() 是估算值，可能突然变为 0。\n移动端效果有限：低端设备空闲时间极少，可能长期不触发。\n🆚 与 requestAnimationFrame 对比\n\nAPI时机用途\n\nrequestAnimationFrame每一帧开始前（约 16ms 一次）动画、视觉更新\nrequestIdleCallback每一帧结束后，若有空闲低优先级后台任务\n\n✅ 两者互补：rAF 保证流畅动画，rIC 避免阻塞动画。\n📦 在现代框架中的使用\nReact：内部调度器受 rIC 启发，但使用自定义实现（因兼容性问题）。\nVue / Svelte：一般不直接使用，但可用于自定义性能优化逻辑。\n推荐：在业务代码中谨慎使用，并做好降级。\n✅ 最佳实践模板\nfunction scheduleIdleWork(workFn, timeout = 2000) {\n  if ('requestIdleCallback' in window) {\n    return requestIdleCallback((deadline) => {\n      if (deadline.timeRemaining() > 0 || deadline.didTimeout) {\n        workFn();\n      }\n    }, { timeout });\n  } else {\n    // fallback: 稍后执行（不阻塞当前任务）\n    return setTimeout(workFn, 0);\n  }\n}\n\n// 使用\nconst id = scheduleIdleWork(() => {\n  console.log('在空闲时执行');\n});\n\n// 取消（如组件卸载时）\n// cancelIdleCallback(id) 或 clearTimeout(id)\n\n🔚 总结\n作用：在浏览器空闲时执行低优先级任务，提升用户体验。\n现状：仅 Chrome/Edge 支持，Firefox/Safari 已放弃。\n建议：\n可用于非关键优化（如预加载、日志上报）。\n必须提供降级方案。\n不要用于核心功能。\n9.AbortController\nAbortController 是 Web 平台提供的一个标准接口，用于中止（取消）一个或多个异步操作，比如 fetch() 请求、定时器、自定义任务等。它提供了一种统一、可组合的方式来处理取消逻辑，避免内存泄漏或无效操作。\n🧠 核心概念\nAbortController：控制器对象，用于触发中止。\nAbortSignal：信号对象，与控制器关联，传递“是否已中止”的状态，并可监听 abort 事件。\n✅ 基本用法\n1. 创建控制器和信号\nconst controller = new AbortController();\nconst signal = controller.signal; // 只读的 AbortSignal\n\n2. 监听中止信号（在异步操作中）\n// 示例：自定义异步任务\nfunction myAsyncTask(signal) {\n  return new Promise((resolve, reject) => {\n    // 检查是否已经中止\n    if (signal.aborted) {\n      reject(new DOMException('操作已中止', 'AbortError'));\n      return;\n    }\n\n    // 监听中止事件\n    signal.addEventListener('abort', () => {\n      reject(new DOMException('操作已中止', 'AbortError'));\n    });\n\n    // 模拟异步操作\n    const timer = setTimeout(() => {\n      resolve('任务完成');\n    }, 3000);\n\n    // 可选：在中止时清理资源\n    signal.addEventListener('abort', () => {\n      clearTimeout(timer);\n    });\n  });\n}\n\n3. 触发中止\nmyAsyncTask(controller.signal)\n  .then(console.log)\n  .catch(e => {\n    if (e.name === 'AbortError') {\n      console.log('任务被用户取消');\n    } else {\n      console.error('其他错误', e);\n    }\n  });\n\n// 1 秒后取消\nsetTimeout(() => {\n  controller.abort(); // 触发 abort 事件，signal.aborted 变为 true\n}, 1000);\n\n🌐 实际应用场景\n1. 取消 fetch 请求（最常见）\nconst controller = new AbortController();\n\nfetch('/api/data', { signal: controller.signal })\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(err => {\n    if (err.name === 'AbortError') {\n      console.log('请求被取消');\n    } else {\n      console.error('网络错误', err);\n    }\n  });\n\n// 取消请求\ncontroller.abort();\n\n✅ 所有现代浏览器都支持 fetch 的 signal 选项。\n2. 取消多个操作（一对多）\n一个 AbortController 可以控制多个异步任务：\nconst controller = new AbortController();\n\nfetch('/api/1', { signal: controller.signal });\nfetch('/api/2', { signal: controller.signal });\nmyAsyncTask(controller.signal);\n\n// 一键取消所有\ncontroller.abort();\n\n3. 与 setTimeout / setInterval 结合\n虽然 setTimeout 本身不支持 signal，但可以手动集成：\nfunction delay(ms, signal) {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(new DOMException('已中止', 'AbortError'));\n      return;\n    }\n\n    const id = setTimeout(resolve, ms);\n    signal?.addEventListener('abort', () => {\n      clearTimeout(id);\n      reject(new DOMException('已中止', 'AbortError'));\n    });\n  });\n}\n\n// 使用\nconst ctrl = new AbortController();\ndelay(5000, ctrl.signal).catch(console.error);\nctrl.abort(); // 立即取消\n\n🔁 与 TaskController（来自 scheduler.postTask）的关系\nTaskController 是 AbortController 的子类，专为调度任务设计。\n它额外支持 priority 设置，并返回 TaskSignal（继承自 AbortSignal）。\n因此，AbortController 是更通用的取消机制，而 TaskController 是其在任务调度场景下的扩展。\n// TaskController 用法（实验性）\nconst taskCtrl = new TaskController({ priority: 'background' });\nscheduler.postTask(myTask, { signal: taskCtrl.signal });\n\n// 也可以直接 abort()\ntaskCtrl.abort();\n\n⚠️ 注意事项\nabort() 只能调用一次，多次调用无副作用。\n中止后，signal.aborted 永远为 true。\n被中止的操作不会自动停止，你需要在代码中主动监听并清理资源（如清除定时器、关闭流等）。\n不要重复使用同一个 AbortController 实例处理不相关的任务，建议按逻辑分组使用。\n在React中的应用\n在 React 中，AbortController 是处理组件卸载后仍可能完成的异步操作（如 fetch 请求、定时器、动画等）的关键工具。它的主要目的是 避免“内存泄漏”或“状态更新已卸载组件” 的警告（例如经典的 Can't perform a React state update on an unmounted component）。\n✅ 典型使用场景\n1. 取消数据请求（最常见）\n当组件在请求完成前被卸载（如用户快速切换路由），应取消请求。\nimport { useEffect, useState } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const controller = new AbortController(); // 创建控制器\n\n    const fetchUser = async () => {\n      try {\n        const res = await fetch(`/api/users/${userId}`, {\n          signal: controller.signal // 传入 signal\n        });\n        const data = await res.json();\n        setUser(data);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          console.error('请求失败:', err);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n\n    // 清理函数：组件卸载时中止请求\n    return () => {\n      controller.abort();\n    };\n  }, [userId]);\n\n  if (loading) return <div>加载中...</div>;\n  return <div>用户名：{user?.name}</div>;\n}\n\n✅ 这样即使组件卸载，也不会尝试调用 setUser，避免警告。\n2. 取消多个并行请求\nuseEffect(() => {\n  const controller = new AbortController();\n\n  Promise.all([\n    fetch('/api/posts', { signal: controller.signal }),\n    fetch('/api/comments', { signal: controller.signal })\n  ])\n  .then(/* ... */)\n  .catch(err => {\n    if (err.name !== 'AbortError') {\n      // 处理真实错误\n    }\n  });\n\n  return () => controller.abort();\n}, []);\n\n3. 结合自定义 Hook 封装\n可以创建一个可复用的 useAbortableFetch：\n// hooks/useAbortableFetch.js\nimport { useEffect, useState } from 'react';\n\nexport function useAbortableFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const controller = new AbortController();\n\n    const fetchData = async () => {\n      try {\n        const res = await fetch(url, { signal: controller.signal });\n        if (!res.ok) throw new Error('请求失败');\n        const json = await res.json();\n        setData(json);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    return () => controller.abort();\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n使用：\nfunction App() {\n  const { data, loading } = useAbortableFetch('/api/data');\n  // ...\n}\n\n4. 取消定时器或动画\n虽然 setTimeout 不原生支持 signal，但可以手动集成：\nuseEffect(() => {\n  const controller = new AbortController();\n\n  const timer = setTimeout(() => {\n    if (!controller.signal.aborted) {\n      setData('更新了！');\n    }\n  }, 3000);\n\n  return () => {\n    controller.abort(); // 标记为中止\n    clearTimeout(timer); // 清理定时器\n  };\n}, []);\n\n或者封装一个支持 signal 的 delay 工具函数（见前文）。\n5. 与 React Router（v6）结合\n在路由切换时自动取消请求：\n// 不需要额外操作！只要在 useEffect 中正确使用 AbortController，\n// 路由切换导致组件卸载时，清理函数会自动执行。\n\n⚠️ 注意事项\n不要忽略 AbortError\n.catch() 中要判断是否是 AbortError，避免把“正常取消”当作错误处理。\n每个 effect 使用独立的 controller\nAbortController，除非你明确需要批量取消。\n不适用于同步操作\nAbortController 只对异步、可中断的操作有效。\nReact 18 严格模式下的双重调用\nAbortController 能确保第一次请求被正确取消，是正常行为，不是 bug。\n🔄 替代方案（现代 React）\nReact Query / SWR：这些数据获取库内部已集成取消逻辑，无需手动管理 AbortController。\nuseEffect cleanup：仍是处理取消的核心机制，AbortController 是其实现细节之一。\n✅ 总结\n\n场景是否需要 AbortController\n\nfetch 请求✅ 强烈推荐\n自定义异步任务（如 WebSocket、定时器）✅ 推荐\n使用 React Query / SWR❌ 不需要（库已处理）\n同步计算❌ 不适用\n\n💡 最佳实践：只要你在 useEffect 中发起异步操作并更新状态，就应考虑使用 AbortController 或等效的取消机制。",
      "hotIndex": 15,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7563950984255438898",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "一个函数超过20行? 聊聊我的函数式代码洁癖",
      "url": "https://juejin.cn/post/7563950984255438898",
      "pubDate": "Thu, 23 Oct 2025 02:28:09 GMT",
      "description": "大家好,我又来了😁\n我得承认，我有个毛病，或者说洁癖吧。\n在Code Review的时候，当我点开一个*.js / *.ts文件，看到一个函数洋洋洒洒地写了50行、80行，甚至更多时，我的第一反应不是去读它的逻辑，而是生理性地发慌😖。\n我会下意识地在评论区留下一句：这个函数是不是太长了？能不能拆一下？\n20行这个数字，是我给自己设的一个 代码量阈值。它不绝对，但足够灵敏。\n我知道，很多人会觉得我这是小题大做、形式主义。但今天我想聊聊，这个洁癖背后，隐藏的是一个被函数式思想洗礼过的、关于代码可维护性、可测试性和认知成本的严肃思考。\n为什么长函数让人如此发慌？😒\n一个超过20行的函数，对我来说，通常意味着三场灾难：\n1. 阅读成本极高\n// 这是一个超过 50 行的函数\n// 目的：根据用户数据生成报告并发送邮件（其实做了三件事）\nfunction handleUserReport(users, sendEmail, isAdmin) {\n  let result = [];\n  let flag = false;\n\n  console.log(\"开始处理用户数据...\");\n\n  for (let i = 0; i < users.length; i++) {\n    let u = users[i];\n    if (u.age > 18) {\n      if (u.active) {\n        if (u.score > 80) {\n          result.push({ name: u.name, status: \"优秀\" });\n          flag = true;\n        } else if (u.score > 60) {\n          result.push({ name: u.name, status: \"良好\" });\n        } else {\n          result.push({ name: u.name, status: \"待提升\" });\n        }\n      } else {\n        if (isAdmin) {\n          result.push({ name: u.name, status: \"非活跃但保留\" });\n        } else {\n          result.push({ name: u.name, status: \"非活跃\" });\n        }\n      }\n    } else {\n      if (u.active) {\n        result.push({ name: u.name, status: \"未成年用户\" });\n      }\n    }\n  }\n\n  console.log(\"用户数据处理完毕\");\n  console.log(\"生成报告中...\");\n\n  let report = \"用户报告：\\n\";\n  for (let i = 0; i < result.length; i++) {\n    report += `${result[i].name} - ${result[i].status}\\n`;\n  }\n\n  if (flag) {\n    console.log(\"存在优秀用户！\");\n  }\n\n  if (sendEmail) {\n    console.log(\"准备发送邮件...\");\n    // 模拟邮件发送逻辑\n    for (let i = 0; i < result.length; i++) {\n      if (result[i].status === \"优秀\") {\n        console.log(`已发送邮件给：${result[i].name}`);\n      }\n    }\n  }\n\n  console.log(\"处理完成。\");\n  return report;\n}\n\n\n上面👆这个50多行的函数，就像一篇没有分段的短文。你必须从头到尾把它加载到你的大脑里，才能理解它到底在干嘛。\n第5行定义的一个flag变量，在第15行被修改了。\n中间夹杂着三层if/else嵌套。\n它到底做了几件事？天知道🤷‍♂️。\n这种函数，是可写，不可读的。写的人洋洋得意，几个月后他自己回来维护，一样骂娘😠。\n2. 根本无法单元测试\n我们来谈谈单元测试。你怎么去测试一个50行的、混合了数据请求、数据格式化和UI状态更新的函数？\n先看代码👇：\n// 一个50行的混合函数：既请求接口、又格式化数据、还更新UI状态\nasync function loadUserProfile(userId) {\n  setLoading(true);\n\n  try {\n    // 1️⃣ 请求数据\n    const response = await fetch(`/api/user/${userId}`);\n    const data = await response.json();\n\n    // 2️⃣ 本地缓存\n    localStorage.setItem('lastUserId', userId);\n\n    // 3️⃣ 格式化数据\n    const displayName = data.firstName + ' ' + data.lastName;\n    const ageText = data.age ? `${data.age}岁` : '未知年龄';\n\n    // 4️⃣ UI状态更新\n    setUser({\n      name: displayName,\n      age: ageText,\n      hobbies: data.hobbies?.join('、') || '无'\n    });\n\n    // 5️⃣ 额外副作用\n    if (data.isVIP) {\n      trackEvent('vip_user_loaded');\n      showVIPBadge();\n    }\n\n    setLoading(false);\n  } catch (error) {\n    console.error('加载失败', error);\n    setError('加载用户信息失败');\n    setLoading(false);\n  }\n}\n\n\n测试代码：\n// 测试代码（伪代码）\ntest('loadUserProfile should set formatted user data', async () => {\n  // Mock 一堆外部依赖\n  global.fetch = jest.fn().mockResolvedValue({\n    json: () => Promise.resolve({ firstName: 'Tom', lastName: 'Lee', age: 28, isVIP: true })\n  });\n  localStorage.setItem = jest.fn();\n  const setUser = jest.fn();\n  const setLoading = jest.fn();\n  const setError = jest.fn();\n  const trackEvent = jest.fn();\n  const showVIPBadge = jest.fn();\n\n  // 还要通过依赖注入或hook替换上下文...\n  await loadUserProfile(123);\n\n  // 然后验证每一步是否被正确调用\n  expect(fetch).toHaveBeenCalledWith('/api/user/123');\n  expect(localStorage.setItem).toHaveBeenCalledWith('lastUserId', 123);\n  expect(setUser).toHaveBeenCalledWith({\n    name: 'Tom Lee',\n    age: '28岁',\n    hobbies: '无'\n  });\n  expect(trackEvent).toHaveBeenCalledWith('vip_user_loaded');\n  expect(showVIPBadge).toHaveBeenCalled();\n  expect(setLoading).toHaveBeenLastCalledWith(false);\n});\n\n\n你根本没法测试。你只能去集成测试。\n为了测试它，你不得不mock掉fetch、localStorage、useState... 你会发现，你的测试代码，比你的业务代码还长、还复杂。\n3. 你看不见的地雷\n函数越长，它顺手去干点脏活的概率就越大。\n举个例子👇：\n// 名字看起来挺纯洁的 —— 获取用户配置\n// 实际上它干了很多事没人知道...\nfunction getUserConfig(userId) {\n  console.log('开始获取用户配置...');\n\n  // 1️⃣ 顺手改了全局变量\n  globalCache.lastRequestTime = Date.now();\n\n  try {\n    // 2️⃣ 发起网络请求\n    const res = fetch(`/api/config/${userId}`);\n    const data = res.json();\n\n    // 3️⃣ 顺手改了一下全局设置\n    window.__APP_MODE__ = data.isAdmin ? 'admin' : 'user';\n\n    // 4️⃣ 顺手写了一点 localStorage\n    localStorage.setItem('lastConfigUser', userId);\n\n    // 5️⃣ 格式化返回数据\n    const config = {\n      theme: data.theme || 'light',\n      lang: data.lang || 'en-US'\n    };\n\n    return config;\n  } catch (err) {\n    console.error('获取配置出错', err);\n\n    // 6️⃣ 顺手派发了一个事件\n    window.dispatchEvent(new CustomEvent('config_load_failed', { detail: { userId } }));\n\n    // 7️⃣ 顺手清空了一个全局标记\n    globalCache.lastRequestTime = null;\n\n    return { theme: 'light', lang: 'en-US' }; // 假装有个默认值\n  }\n}\n\n\n调用者根本不知道它干了些什么 😵‍💫\nconst config = getUserConfig(42);\nconsole.log(config.theme); // 看起来很正常\n\n// 但此时：\n// window.__APP_MODE__ 已被改动\n// localStorage 里写入了 lastConfigUser\n// globalCache.lastRequestTime 已变化\n// 如果请求失败，还会触发一个全局事件\n\n\n它在函数的中间，顺手改了一个全局变量。\n它在catch块里，顺手dispatch了一个event。\n它顺手往window上挂了个东西。\n这种充满隐形副作用的函数，是系统中最不可预测的地雷。你根本不知道你调用它，会影响到哪里。\n谈一谈 函数式思想\n我的洁癖，其实是来源于函数式编程思想。\n我并不追求写出高阶组合子那些高深的东西。我只坚守两个最朴素的原则：\n函数必须小，且只做一件事\n这是 单一职责原则 的终极体现。一个函数，就只做一件事。\ngetUserData就只负责fetch。\nformatUserData就只负责格式化。\nsetUserState就只负责更新状态。\n一个函数超过20行，对我来说，往往就是它至少做了两件以上的事情的强烈信号。\n追求纯函数，隔离掉它的一切副作用\n一个纯函数：给它什么（入参），它就吐出什么（返回），绝不搞小动作。\n我追求的目标，就是把所有的业务逻辑和计算，都抽成纯函数。而那些不得不做的脏活（比如API请求、DOM操作），则被我隔离在最外层的协调函数里。\n重构一个函数\n我们来看一个在React项目里，极其常见的函数（绝对超过20行）：\n// 场景：一个提交用户注册的函数\nasync function handleRegister(formData) {\n  setLoading(true);\n  \n  // 1. 业务逻辑：验证\n  if (!formData.username) {\n    showToast('用户名不能为空');\n    setLoading(false);\n    return;\n  }\n  if (formData.password.length < 6) {\n    showToast('密码不能少于6位');\n    setLoading(false);\n    return;\n  }\n  \n  // 2. 业务逻辑：数据转换\n  const apiPayload = {\n    user: formData.username,\n    pass: btoa(formData.password + 'my_salt'), // 假设的加密\n    source: 'web',\n    registerTime: new Date().toISOString(),\n  };\n\n  // 3. 副作用：API请求\n  try {\n    const result = await api.post('/register', apiPayload);\n    \n    // 4. 副作用：更新UI状态\n    if (result.code === 200) {\n      setUserData(result.data.user);\n      trackEvent('register_success');\n      showToast('注册成功！');\n      router.push('/dashboard');\n    } else {\n      showToast(result.message);\n    }\n  } catch (err) {\n    showToast(err.message);\n    trackEvent('register_fail', { msg: err.message });\n  } finally {\n    setLoading(false);\n  }\n}\n\n这个函数，就是一场灾难。它混合了4-5种职责，你根本没法测试它。\n重构过程如下👇：\n1.先分离纯业务逻辑（可测试）\n// 纯函数1：验证逻辑 (可独立测试)\n// (5行)\nexport function validateRegistration(formData) {\n  if (!formData.username) return '用户名不能为空';\n  if (formData.password.length < 6) return '密码不能少于6位';\n  return null; // 验证通过\n}\n\n// 纯函数2：数据转换 (可独立测试)\n// (7行)\nexport function createRegisterPayload(formData) {\n  return {\n    user: formData.username,\n    pass: btoa(formData.password + 'my_salt'),\n    source: 'web',\n    registerTime: new Date().toISOString(),\n  };\n}\n\n2.再分离它的副作用\n// 副作用函数1：API调用\n// (3行)\nexport async function postRegistration(payload) {\n  return api.post('/register', payload);\n}\n\n// 副作用函数2：处理成功后的UI逻辑\n// (6行)\nfunction handleRegisterSuccess(userData) {\n  setUserData(userData);\n  trackEvent('register_success');\n  showToast('注册成功！');\n  router.push('/dashboard');\n}\n\n// 副作用函数3：处理失败后的UI逻辑\n// (3行)\nfunction handleRegisterFail(error) {\n  showToast(error.message);\n  trackEvent('register_fail', { msg: error.message });\n}\n\n3.最后重组函数\n现在，我们原来的handleRegister函数，变成了一个清晰的调用者：\n// (18行)\nasync function handleRegister(formData) {\n  // 1. 验证\n  const validationError = validateRegistration(formData);\n  if (validationError) {\n    showToast(validationError);\n    return;\n  }\n  \n  setLoading(true);\n  try {\n    // 2. 转换\n    const payload = createRegisterPayload(formData);\n    // 3. 执行\n    const result = await postRegistration(payload);\n    // 4. 响应\n    if (result.code === 200) {\n      handleRegisterSuccess(result.data.user);\n    } else {\n      handleRegisterFail(new Error(result.message));\n    }\n  } catch (err) {\n    handleRegisterFail(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n等等！你这个handleRegister函数，不还是快20行了吗？😂\n是的，但你发现区别了吗？这个函数，几乎没有任何逻辑 ，它只负责调用其他小函数。它像一个流程图，清晰得一目了然。\n而所有的业务逻辑（validate和createPayload），都被我拆分到了可独立测试、可复用、可预测的纯函数里。这，就是这次的重构的价值。\n20行代码的标准 不是一个KPI，它是一个预警。\n它在提醒我们，这个函数的 负载 可能已经超标了，它在 单一职责 的路上可能已经走偏了。\n这种洁癖，不是为了追求代码的短小，而是为了追求代码的简单和可预测。\n在一个由几十万行代码构成的、需要长期维护的系统里，简单和可预测，是比炫技（屎代码💩），要宝贵一百倍😁。",
      "hotIndex": 16,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7563928374277750793",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "Sentry 都不想接，这锅还让我背？这xx工作我不要了！",
      "url": "https://juejin.cn/post/7563928374277750793",
      "pubDate": "Thu, 23 Oct 2025 01:53:47 GMT",
      "description": "前端出了问题，但总是“查无此人”\n之前在一家体量不算大的公司，我们团队负责维护一个面向 C 端用户的 SaaS 系统。\n但很快，我们就遇到一个反复出现、却又怎么也搞不定的“无语问题”。\n有客户反馈说：页面点不动了，卡死了。\n于是我们第一时间去翻后端接口日志，结果却显示一切正常，没有报错、没有异常，连一个 500 都没有。\n但前端同学也很无语：\n用户只说“打不开”，但没有截图、没有步骤，连系统版本都不清楚；\n再加上这类问题是个例居多，重现概率几乎为零；\n我们能做的，只剩下“老三样”：让用户清缓存、刷新页面、重新登录......\n所以就变成了前端同学每天加班查代码、调兼容性、测不同浏览器，\n终于，前端同学提了建议：\n“要不我们接个前端监控吧？\n大家一听，也确实觉得挺不错的。\n但现实很快泼了冷水......\n前端想接监控，运维说“没必要”\n虽然sentry有云系统，但是由于项目涉及一些私有化部署和用户数据，安全层面考虑，我们必须 自建 Sentry 服务。\n但当前端去找运维申请服务器时，运维那边的反馈是这样的：\n“公司不是已经有监控系统了吗？\n再加上自建 Sentry 的门槛也不低，\n至少得有一台 4 核 8G 的独立服务器，部署起来还得专人维护。\n所以这个提议，第一次就被驳回了。\n但问题依旧在那：\n后来前端负责人出面找运维进行了友好的交流，互相问候了一下，突出了前端监控的重要性和必要性。\n最终这件事才得以推进，Sentry 的前端私有化监控系统正式落地。\n从后端写前端，才真正理解“监控到底有多重要”\n那前端到底有没有必要接入监控系统呢？\n我一直是做后端的，对 Sentry 并不陌生，\n那时候我对“前端要不要接监控”这事，其实也没啥感觉。\n直到后来我开始写前端，特别是做面向 C 端用户的系统之后......\n总是有一些无语用户 拿着已经淘汰的机型 浏览器来给我提bug。\n而且偏偏这些问题，总爱挑在下班时间冒出来，\n也是在这种时候我我才体会到做后端的美好 有监控是真提莫好啊。\nSentry 介绍\nSentry 是一个用来监控应用错误的系统，简单来说，它能在我们代码出问题的时候第一时间记录下详细的异常信息。\nSentry主要能做哪些事\n最重要的是它能帮我们做这三件事：错误上报、性能监控、自定义埋点。\n第一，错误上报。这是我们最需要的功能。当前端页面报错时，比如用户打开页面出现白屏、控制台有 JS 异常、按钮点击崩溃等，Sentry 能自动把这些错误采集上来，并记录报错信息、文件名、报错堆栈、用户的操作路径、操作系统、浏览器版本等信息。更重要的是，如果我们配置了 sourcemap，还能还原成报错的源代码位置，方便我们来精准定位 bug。\n第二，性能监控。Sentry 也能采集页面的关键性能指标（比如首屏加载时间、路由切换耗时、资源加载耗时等），帮助我们了解页面是否存在性能瓶颈。特别是对于 C 端项目来说，前端性能有时候影响的不只是用户体验，甚至可能直接导致功能失败。\n第三，自定义埋点。除了系统自动采集的错误或性能数据，我们当然也可以手动埋点上报一些业务相关的异常，比如用户下单失败、登录异常、接口超时等场景。通过自定义事件上报，我们就可以把监控系统和我们的业务场景更紧密地结合起来，提升排查问题的效率。\nSentry部署方式\nSentry 的部署方式主要有两种：\n第一种是 SaaS 模式，也就是使用官方提供的托管服务sentry.io 。这个最方便，注册账号后就可以用，不用自己部署服务器。不过它有免费额度限制，比如每天只支持最多5000 个事件（event），超了就得升级套餐，适合用来做功能验证或者小量使用。\n第二种是 私有化部署，就是我们自己搭建一套 Sentry 服务，所有的数据都存在自己服务器里，安全性更高，也没有事件数的限制。但相应地，就需要占用自己的服务器资源，官方推荐至少 4 核心 8G 内存起步，还要配置 Redis、PostgreSQL、Cron 等配套组件，整体部署成本相对较高。\n如果团队对数据隐私比较敏感，或者希望做更深入的自定义，那就适合选私有化部署；但如果只是前期简单接入体验功能，直接用 SaaS 模式就足够了哈。\n接入 Sentry\n我们以一个 Vue3 项目为例，来讲讲前端怎么接入 Sentry。\n如果用的是其他前端框架，比如 React、Angular、小程序，或者是后端语言（Java、Python、Go 等），也都可以参考官方文档（docs.sentry.io）找到对应接入方式，这里就不展开讲了。\n我们接下来的内容，以 Vue3 + Vite 项目为例，演示如何接入 Sentry，包括 SDK 配置、SourceMap 上传、前端错误定位等完整流程。\n本次我们以 Sentry 官网的免费版本为例进行演示。\n第一步 注册账号并设置语言\n首先，访问 sentry.io 注册账号。注册完成后，点击页面左下角头像，进入 User Settings。\n在这个页面里，可以根据自己习惯调整一些基础设置，比如语言、时区、界面主题（深色 / 浅色模式）等。设置好之后，后续在查看错误信息时会更清晰，也方便排查问题。\n\n第二步 创建项目\n基础信息设置好之后，我们就可以开始创建项目了。\n点击左上角的头像，选择「项目」，进入项目管理页。点击「创建项目」后，会进入如下界面：\n\n在平台选择里，选择 VUE；\n设置告警频率（默认即可，后面也可以再改）；\n填写项目名称、分配到对应团队，最后点击「创建项目」即可。\n这一步完成后，Sentry 会为我们生成一份接入代码，包含 DSN 地址、初始化方式等内容，稍后我们会用到。\n\n第三步 接入 Sentry 到 Vue3 项目中\n我们现在已经创建好项目，接下来就是把 Sentry 接入到 Vue 应用了。\n1. 安装依赖\n我们以 pnpm 为例（也可以用 npm 或 yarn）：\npnpm add @sentry/vue\n\n2. 新建 sentry.ts 文件\n在 src 目录下新建一个 sentry.ts 文件，用于统一初始化配置：\n// src/sentry.ts\nimport * as Sentry from \"@sentry/vue\";\nimport type { App } from \"vue\";\n\nexport function setupSentry(app: App) {\n    Sentry.init({\n        app,\n\n        // Sentry 项目的 DSN 地址（在项目创建页可以看到）\n        dsn: import.meta.env.VITE_SENTRY_DSN,\n\n        // 当前环境（如 dev、test、prod）\n        environment: import.meta.env.MODE || 'development',\n\n        // 版本号信息，用于错误定位时区分版本差异，使用统一注入的版本号\n        release: __RELEASE__,\n\n        // 是否开启调试（开发阶段建议为 true，线上建议关闭）\n        debug: true,\n\n        // 性能监控采样率（建议开发阶段设为 1.0）\n        tracesSampleRate: 1.0,\n    });\n}\n\n3. 在入口文件中初始化\n在 main.ts（或 main.js）中引入并调用 setupSentry：\n// main.js\nimport { createApp } from 'vue'\nimport './style.css'\nimport App from './App.vue'\nimport { setupSentry } from './sentry'\n\nconst app = createApp(App)\n\n// 初始化 Sentry\nsetupSentry(app)\n\napp.mount('#app')\n\n通过上面代码可以看到我们没有直接在代码里写死 DSN 和环境，而是通过 import.meta.env 从 .env 配置中读取，原因主要有两个：\n方便按环境区分配置：不同的部署环境（开发、测试、生产）通常用不同的 DSN、不同的环境名，通过 .env.development、.env.production 文件分别设置，就不用每次改代码。\n提升安全性与灵活性：DSN 属于敏感信息，不建议直接写死在源码中。通过环境变量注入，只在打包阶段读一次，既安全又灵活，也符合前端项目的最佳实践。\n这样配置完之后，Sentry 就已经接入成功了。只要页面上有 JS 报错，Sentry 就会自动帮我们捕获并上报。\n为了确认是否真的生效，我们可以先写个小 demo 来验证一下。比如在某个页面或者组件里故意抛个错误，看看能不能在 Sentry 后台看到报错信息。\n第三步：写个小 demo 测试一下\nSentry 配置好了，当然要测试一下它到底有没有生效。\n我们可以随便找一个组件，比如首页的 Home.vue，在 onMounted 里手动抛个错：\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue';\n\nonMounted(() => {\n  // 故意抛出一个错误，测试 Sentry 是否能捕获\n  throw new Error('这是一个用于测试 Sentry 的前端错误');\n});\n</script>\n\n页面一加载，就会抛出错误。刷新页面后，稍等几秒，我们就可以在 Sentry 控制台看到这条报错了（如果设置了中文，会显示为“未处理的异常”等字样）。\n\n在 Sentry 控制台的 Issues 页面中，我们能看到刚刚上报的错误项：\n页面左上方可以选择项目（如 sentry_vue3），中间能看到报错的标题和出现时间。\n我们点击进去可以查看详细的错误信息。\n进入错误详情页后，可以看到这次异常的基本信息，例如：\n错误类型：Error\n报错内容：这是一个用于测试 Sentry 的前端错误\n出错文件：src/pages/demo.vue 第 8 行\n浏览器、系统、设备等信息\n跟踪堆栈：包括错误抛出的具体位置及调用路径\n\n往下滚动还能看到更多上下文信息，包括：\n请求信息：错误发生在哪个页面（比如 localhost:5174）\n标签信息：操作系统、浏览器、环境（我们配置的 environment 字段会显示在这里）\n设备信息：品牌型号、地理位置、User-Agent 等\n版本信息：我们在初始化时传入的 release 字段也会出现在这里\n\n整体来看，Sentry 会自动帮我们收集并整理这次错误的上下文环境，非常方便用于问题定位，尤其是线上问题，哪怕用户无法复现，我们也能第一时间拿到关键信息。\n增强 Sentry 错误捕获能力：三类常见未被默认捕获的场景补全\n在前面我们已经完成了 Sentry 的接入，并通过一个简单的报错验证了它的基础功能可以正常工作。但在真实项目中，仅靠默认配置并不能捕获所有类型的前端异常。有些报错是不会自动被 Sentry 感知和上报的，如果我们不手动处理，就很容易漏掉关键错误，影响排查效率。\n接下来，我们补充三种最常见的“漏网之鱼”场景，并提供对应的解决方案，让 Sentry 的异常捕获能力更完整。\n场景一：Vue 组件内部报错，Sentry 没收到\n常见例子：\n// setup() 中写错了变量名\nconst a = b.c; // b 根本不存在\n\n为什么会漏掉？\n<script setup> 语法中），有时不会触发 Sentry 的全局监听机制。Vue 会自己处理这些错误，但如果我们没有配置 app.config.errorHandler，Sentry 是无法感知的。\n解决方法：\napp.config.errorHandler = (err, vm, info) => {\n    console.error(\"[Vue Error]\", err, info);\n    Sentry.captureException(err);\n};\n\n这段代码放在我们的 sentry.ts 中 Sentry.init(...) 之后即可。它能确保组件中发生的报错也能正常被上报。\n场景二：Promise 异常没有 catch，被悄悄吞掉\n常见例子：\n// 忘了写 catch\nfetch('/api/data').then(res => res.json());\n\n或者：\nPromise.reject(\"请求失败了\");\n\n为什么会漏掉？\nwindow.onerror，也不会被 Vue 捕获。它们属于 Promise 的“未处理拒绝（unhandledrejection）”，需要手动监听。\n解决方法：\nwindow.addEventListener(\"unhandledrejection\", (event) => {\n    console.error(\"[Unhandled Promise Rejection]\", event.reason);\n    Sentry.captureException(event.reason);\n});\n\n加上这个监听后，任何未 catch 的 Promise 错误都会被补上报。\n场景三：JS 同步错误没有被捕捉\n常见例子：\n// 直接抛出异常\nthrow new Error(\"代码报错了\");\n\n// 访问不存在的变量\nconsole.log(notDefinedVar);\n\n为什么会漏掉？\n解决方法：\nwindow.addEventListener(\"error\", (event) => {\n    console.error(\"[Global Error]\", event.error || event.message);\n    Sentry.captureException(event.error || event.message);\n});\n\n通过这个监听，我们就可以捕获诸如 throw new Error(...)、运行时访问空对象、空方法等同步错误。\n最终效果：\n把这三类监听逻辑补充进 sentry.ts，放在初始化之后，我们就可实现一个更完整、更稳定的前端异常捕获系统：\n// src/sentry.ts\nimport * as Sentry from \"@sentry/vue\";\nimport type { App } from \"vue\";\n\nexport function setupSentry(app: App) {\n    Sentry.init({\n        // Vue 应用实例，用于自动捕获 Vue 组件错误（必须传）\n        app,\n\n        // Sentry 项目 DSN 地址，用于上报事件\n        dsn: import.meta.env.VITE_SENTRY_DSN,\n\n        // 当前运行环境（用于在 Sentry 中区分 dev / test / prod）\n        environment: import.meta.env.MODE || 'development',\n\n        // 版本号信息，用于错误定位时区分版本差异\n        release: __RELEASE__,\n\n        // 开启调试模式，开发阶段建议开启，生产建议关闭\n        debug: true,\n\n        // 性能采样率，建议开发阶段为 1.0，生产为 0.1 或更低\n        tracesSampleRate: 1.0,\n    });\n\n\n    /**\n     * Vue 组件级错误捕获（setup() / template 中的报错）\n     */\n    app.config.errorHandler = (err, vm, info) => {\n        console.error(\"[Vue Error]\", err, info);\n        Sentry.captureException(err);\n    };\n\n    /**\n     * 全局 Promise 异常（async/await 未 catch / new Promise 报错）\n     * 比如：Promise.reject(\"失败\")，或者接口请求异常未处理\n     */\n    window.addEventListener(\"unhandledrejection\", (event) => {\n        console.error(\"[Unhandled Promise Rejection]\", event.reason);\n        Sentry.captureException(event.reason);\n    });\n\n    /**\n     * 全局同步错误（JS 报错 / try-catch 漏掉的错误）\n     * 比如：throw new Error(\"xx\")，或运行期 ReferenceError 等\n     */\n    window.addEventListener(\"error\", (event) => {\n        console.error(\"[Global Error]\", event.error || event.message);\n        Sentry.captureException(event.error || event.message);\n    });\n}\n\n主动上报错误：捕获那些不会自动抛出的异常\n虽然我们已经通过自动监听覆盖了大多数前端异常，但实际开发中还有很多“业务逻辑错误”并不会抛异常，比如：\n某接口返回了错误码（但没报错）\n登录失败、权限不足等场景\n某第三方 SDK 内部 silent fail\n某些组件逻辑执行失败，但 catch 掉了没抛\n这种情况下，程序表面看起来没问题，控制台也没报错，但我们大前端其实已经背锅了！！！。要想让这些问题也被 Sentry 收到，就要靠主动上报。\n所以我们可以在 sentry.ts 中新增两个工具函数：\n/**\n * 主动上报错误（可用于 catch 中或逻辑异常手动触发）\n * @param error 异常对象\n * @param context 可选的上下文标签（如 \"登录失败\"）\n */\nexport function reportError(error: unknown, context?: string) {\n    console.error(\"[Manual Error]\", error, context);\n    Sentry.captureException(error, {\n        tags: context ? { context } : undefined,\n    });\n}\n\n/**\n * 安全执行函数：用于包装可能抛出异常的逻辑，避免中断流程\n * @param fn 要执行的函数\n * @param context 错误发生时附加的上下文信息\n */\nexport function safeExecute(fn: () => void, context?: string) {\n    try {\n        fn();\n    } catch (err) {\n        reportError(err, context);\n    }\n}\n\n使用示例：\n场景一：接口错误但没有抛异常\nconst res = await fetch('/api/login');\nconst json = await res.json();\nif (json.code !== 0) {\n    reportError(new Error(\"登录失败\"), \"登录接口返回错误\");\n}\n\n场景二：包一层逻辑避免程序中断\nsafeExecute(() => {\n    // 某些不稳定逻辑\n    riskyFunction();\n}, \"支付模块逻辑异常\");\n\n为什么我们推荐这样做呢？\n业务异常不一定是技术异常，但同样需要排查\n报错信息中带有 context 标签，可以帮助我们快速定位问题来源（登录？支付？加载首页？）\nsafeExecute 可以在保底兜错的同时确保错误不会悄无声息地被吞掉\n最最最重要的是防止后端甩锅！！！\n补充用户上下文信息：让错误背后的“人”和“设备”清清楚楚\n前面我们讲了如何捕获错误、主动上报、加行为记录等等，但我们在实际用 Sentry 看报错详情时，很可能会发现一个问题：\n“虽然报错内容我看懂了，但……这是谁的错？是在什么设备上报的？他从哪里进来的？ ”\n默认情况下，Sentry 只会收集一些非常基础的信息，比如文件堆栈、报错文件、代码行号，但对于业务人员和开发来说，这些技术信息远远不够还原问题现场。\n比如以下这些关键字段，往往都是空的：\n当前用户 ID / 手机号\n来源渠道（扫码进入？分享页面？哪个渠道？）\n设备信息（iPhone 还是 Android？哪个浏览器？网络情况？）\n用户行为路径（点了什么？进入了哪个页面？）\n所以我们需要在用户登录后或页面初始化时，手动补充这些上下文信息，帮助我们更快地定位问题。\n第一步：识别设备信息（device info）\n我们可以在 src/utils/deviceInfo.ts 中封装一个方法，用来识别用户使用的设备、系统、浏览器等基础信息。\nexport function getDeviceBrand(): string {\n  const ua = navigator.userAgent.toLowerCase();\n  if (ua.includes(\"iphone\")) return \"Apple\";\n  if (ua.includes(\"huawei\")) return \"Huawei\";\n  if (ua.includes(\"xiaomi\")) return \"Xiaomi\";\n  if (ua.includes(\"oppo\")) return \"OPPO\";\n  if (ua.includes(\"vivo\")) return \"Vivo\";\n  if (ua.includes(\"samsung\")) return \"Samsung\";\n  return \"Unknown\";\n}\n\nexport function getDeviceModel(): string {\n  return navigator.userAgent;\n}\n\nexport function getOS(): string {\n  const platform = navigator.platform.toLowerCase();\n  const ua = navigator.userAgent.toLowerCase();\n  if (platform.includes(\"win\")) return \"Windows\";\n  if (platform.includes(\"mac\")) return \"macOS\";\n  if (/android/.test(ua)) return \"Android\";\n  if (/iphone|ipad|ipod/.test(ua)) return \"iOS\";\n  if (platform.includes(\"linux\")) return \"Linux\";\n  return \"Unknown\";\n}\n\nexport function getBrowser(): string {\n  const ua = navigator.userAgent;\n  if (ua.includes(\"Chrome\") && !ua.includes(\"Edg\")) return \"Chrome\";\n  if (ua.includes(\"Safari\") && !ua.includes(\"Chrome\")) return \"Safari\";\n  if (ua.includes(\"Firefox\")) return \"Firefox\";\n  if (ua.includes(\"Edg\")) return \"Edge\";\n  return \"Unknown\";\n}\n\nexport function getNetworkType(): string {\n  const nav = navigator as any;\n  return nav.connection?.effectiveType || \"unknown\";\n}\n\n第二步：在 sentry.ts 中设置用户、设备、行为等上文\n/**\n * 设置当前用户信息（在用户登录后调用）\n */\nexport function setSentryUserInfo(user: {\n  id: string;\n  username?: string;\n  email?: string;\n  level?: string;\n  channel?: string;\n  phone?: string; // 已脱敏，如 138****5678\n}) {\n  Sentry.setUser({\n    id: user.id,\n    username: user.username,\n    email: user.email,\n    phone: user.phone,\n  });\n\n  if (user.channel) {\n    Sentry.setTag(\"channel\", user.channel);\n  }\n  if (user.level) {\n    Sentry.setTag(\"user_level\", user.level);\n  }\n}\n\n/**\n * 设置设备上下文信息\n */\nexport function setDeviceContext() {\n  Sentry.setContext(\"device\", {\n    brand: getDeviceBrand(),\n    model: getDeviceModel(),\n    os: getOS(),\n    browser: getBrowser(),\n    screen: `${window.screen.width}x${window.screen.height}`,\n    network: getNetworkType(),\n  });\n}\n\n/**\n * 设置其他自定义标签信息\n */\nexport function setSentryTags(tags: Record<string, string>) {\n  Object.entries(tags).forEach(([key, value]) => {\n    Sentry.setTag(key, value);\n  });\n}\n\n/**\n * 添加用户行为记录（Breadcrumb）\n */\nexport function addSentryBreadcrumb(info: {\n  category: string;\n  message: string;\n  level?: \"info\" | \"warning\" | \"error\";\n  data?: Record<string, any>;\n}) {\n  Sentry.addBreadcrumb({\n    category: info.category,\n    message: info.message,\n    level: info.level || \"info\",\n    data: info.data,\n    timestamp: Date.now() / 1000,\n  });\n}\n\n第三步：在登录成功或页面初始化时调用这些方法\n// 设置模拟用户信息\nsetSentryUserInfo({\n  id: \"1000000\",\n  username: \"中秋游客\",\n  channel: \"midautumn-h5\",\n  level: \"guest\",\n  phone: \"138****5678\", // 已脱敏\n});\n\n// 设置页面标签（可筛选、聚合用）\nsetSentryTags({\n  page: \"midautumn-event\",\n  platform: \"h5\",\n  env: import.meta.env.MODE || \"development\",\n});\n\n// 设置设备上下文信息\nsetDeviceContext();\n\n可选：记录用户行为路径（面包屑）\n面包屑的作用，就是帮我们还原“出错前用户都干了啥”。\naddSentryBreadcrumb() 主动记录下来。\n// 用户点击“进入活动页”\naddSentryBreadcrumb({\n  category: \"navigation\",\n  message: \"进入订单页\",\n});\n\n或者使用全局路由守卫自动记录所有页面跳转：\nrouter.afterEach((to) => {\n  addSentryBreadcrumb({\n    category: \"navigation\",\n    message: `用户进入页面：${to.name || \"unknown\"}`,\n    data: { path: to.fullPath }, // 可在 data 里加自定义参数，比如页面路径、来源等\n  });\n});\n\n第四步：验证上下文信息是否成功\n比如我们写一段简单的函数，故意抛出一个错误，用来测试：\nfunction throwError() {\n  throw new Error(\"这是一个测试错误，用于验证 Sentry上下文 错误捕获功能。\");\n}\n\n执行完后，Sentry 控制台就会收到一条错误。\n\n我们打开错误详情页面就可以在事件顶部清晰看到：\n用户 ID：test_user_001\n浏览器、系统、环境等基础信息\n\n再往下展开，就会看到更详细的信息\n用户名、手机号、地域定位\n浏览器版本、系统版本、网络类型等\n\n这些信息都能帮我们快速还原出问题用户的设备和环境。\n加上这些后 我们这边收到的错误报警邮件有关用户信息也清晰可见：\n\n\n我们还可以加上一些“用户干了什么”的记录，比如：\naddSentryBreadcrumb({\n  category: \"navigation\",\n  message: \"进入中秋活动页\",\n});\n\n这样在 Sentry 中就能看到这条导航事件方便我们追踪用户在报错之前点了什么、跳转了哪儿。\n\n大概总结下\n虽然设置上下文信息看似繁琐，但带给我们的价值很直接：\n报错信息中能看到哪个用户、在哪个页面、使用什么设备出了问题\n可以根据渠道、环境、等级等进行错误聚合和筛选\n加入用户行为记录（Breadcrumb）可以还原问题发生前的操作路径\n日志也能跟业务人员“对得上话”了，不再只是开发自己看懂的异常栈\n那什么是 SourceMap呢，为什么我们需要它？\n我们先回顾下前面测试的那个例子：\n当我们在项目中手动触发一个错误，比如：\nfunction throwError() {\n  throw new Error(\"这是一个测试错误，用于验证 Sentry 上下文捕获功能。\");\n}\n\n在本地运行时，我们Sentry 报错详情里能准确显示是哪一行、哪一段代码出了问题，甚至堆栈信息都非常清晰。\n\n但是别忘了这只是因为我们还没打包，也就是在「开发模式」下运行，代码结构是完整的。\n但是一旦上线，情况就变了\n我们实际部署项目时，都会执行类似这样的构建命令：\npnpm build\n\n这一步会把所有 JS 文件压缩、混淆，删除注释、缩短变量名、合并文件，生成的代码会变成这种形式：\nfunction a(t){try{r(t)}catch(n){console.error(n)}}\n\n这是浏览器喜欢的格式，但对人来说几乎没法看懂。\n如果这时候线上用户触发了一个错误，Sentry 捕获的堆栈信息也会变成这样：\nat chunk-abc123.js:1:1735\n\n我们就根本不知道这段报错到底是哪个文件、哪一行，甚至连哪个函数都不知道。\n这时候就需要 SourceMap 来救场了，SourceMap 就是用来建立「压缩后代码」和「原始代码」之间映射关系的文件。\n只要我们在打包之后把 .map 文件上传到 Sentry，它就能根据这些映射文件，把上面那种看不懂的堆栈信息，自动还原回我们写的源码，准确标注是哪一个文件、函数、哪一行代码出了问题。\n简单来说：\n打包后代码压缩了，看不懂了。\n.map 文件。\n哪可能会问上传 SourceMap 会不会把源码暴露出去？\n这个问题简单来说：\n默认情况下，肯定是会暴露的。\n为什么这么说呢？\n因为我们每次执行 vite build 或 npm run build 时，生成的 .js 文件旁边都会有一个 .js.map 文件。如果我们把整个 dist 目录原封不动部署到线上服务器，那用户只要打开浏览器、F12 控制台一看，就能直接访问：\nhttps://我们的域名/assets/app.js.map\n\n点开之后就是我们项目的源码结构，变量名、注释、函数逻辑一清二楚。\n我们把项目源码白白送出去了。\n那我们需要怎么做呢？\n我们真正需要的，其实只是把这些 .map 文件上传给 Sentry 用于还原堆栈，而不是暴露给所有人访问。\n推荐的流程是：\n本地或 CI 构建时生成 .map 文件；\n使用 Sentry CLI 或插件上传 .map 到 Sentry；\n上传成功后，立刻删除本地的 .map 文件；\n最终部署时，只发布 .js 文件，不包含 .map 文件。\n这样一来：\nSentry 能还原报错堆栈；\n用户访问不到 .map；\n项目源码就不会被轻易扒走了。\n总之记住一句话：SourceMap 是给 Sentry 用的，不是给别人看的。\n接下来我们就来讲讲这个上传流程怎么做：包括怎么配置、怎么自动上传、怎么验证效果。\n如何配置 SourceMap 上传到 Sentry\n接下来我们就开始配置一下，把前端项目打包后的 .map 文件上传到 Sentry，用于错误堆栈还原。\n1. 安装依赖\n我们先安装 Sentry 提供的插件和命令行工具：\npnpm add -D @sentry/vite-plugin @sentry/cli\n\n2. 配置环境变量\n为了让上传工具知道我们是谁、我们的项目在哪、发的是哪个版本，我们需要配置几个环境变量。\n.env.production 文件，把 Sentry 所需的配置写在里面即可：\n# 从 Sentry 设置页面获取\nVITE_SENTRY_AUTH_TOKEN=你的AuthToken\nVITE_SENTRY_ORG=你的组织名\nVITE_SENTRY_PROJECT=你的项目名\n\n# 如果我们使用的是私有化部署（比如自建的 Sentry 服务器）默认就是https://sentry.io\nVITE_SENTRY_URL=https://sentry.io/\n\n# 可选：设置当前的 release 版本号，可以是 1.0.0，也可以是 git commit hash\nVITE_SENTRY_RELEASE=your-project@1.0.0\n\n这些配置只会在打包构建时（vite build）被加载，开发环境下不会生效，也不需要在 .env.development 或 .env.local 中重复配置。\n其实我们可以把 VITE_SENTRY_RELEASE 设置为当前 Git 提交版本（git rev-parse --short HEAD），这样上传的 SourceMap 文件可以精准匹配线上版本，后面我们会演示如何自动设置。\n3.修改 vite.config.ts\n我们需要在 Vite 配置中引入 Sentry 插件，并做一些初始化设置：\nimport { defineConfig, loadEnv } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport path from 'path'\nimport pkg from './package.json';\nimport { sentryVitePlugin } from '@sentry/vite-plugin';\nimport { execSync } from 'child_process';\n\n// https://vitejs.dev/config/\nexport default defineConfig(({ mode }) => {\n    const env = loadEnv(mode, process.cwd())\n\n    const project = env.VITE_SENTRY_PROJECT || pkg.name\n    const version = execSync('git rev-parse --short HEAD').toString().trim()\n    const release = `${project}@${version}`\n\n    return {\n        plugins: [\n            vue(),\n            sentryVitePlugin({\n                url: env.VITE_SENTRY_URL, // 如果用的是官方 sentry.io，也可以省略\n                org: env.VITE_SENTRY_ORG,\n                project: env.VITE_SENTRY_PROJECT,\n                authToken: env.VITE_SENTRY_AUTH_TOKEN,\n                release: release,\n                include: './dist',\n                urlPrefix: '~/',\n                deleteAfterCompile: true, // 上传后删除 .map 文件\n            }),\n        ],\n        resolve: {\n            alias: {\n                '@': path.resolve(__dirname, './src'),\n            },\n        },\n        define: {\n            __RELEASE__: JSON.stringify(release), // 注入全局常量\n            __APP_VERSION__: JSON.stringify(pkg.version),\n        },\n        build: {\n            sourcemap: true, // 必须开启才能生成 .map\n        },\n    }\n})\n\n4. 修改构建命令，删除残留 .map 文件（可选）\n虽然我们配置了 deleteAfterCompile: true，但有些场景下我们可能还想手动确保 .map 不被部署，可以在 package.json 的构建命令里加上：\n{\n  \"scripts\": {\n    \"build\": \"vite build && find ./dist -name '*.map' -delete\"\n  }\n}\n\n这个命令会先构建项目，再扫描 dist 目录，把所有 .map 文件都删除。\n这样就能确保我们部署上线时不会把 SourceMap 文件一并带上，只上传给 Sentry，确保安全。\n5.如何获取 Sentry 的 Auth Token？\n为了让 sentry-cli 或插件能识别我们是谁，并授权上传 SourceMap，我们需要生成一个 Sentry 的 Token。下面是获取步骤：\n第一步：进入 Sentry 设置页面\n在左侧菜单栏，点击左下角的齿轮图标（Settings）进入设置界面。\n\n第二步：创建新的 Token\n在 Organization Tokens 页面：\n点击右上角的「创建新的令牌」按钮；\n会弹出一个创建表单：\n姓名（Name） ：填一个方便识别的名字就行，比如项目名 sentry_vue3；\n作用域（Scopes） ：选择 org:ci，这个包含了我们上传 SourceMap 所需的权限（Release Creation 和 Source Map Upload）；\n\n然后点击「创建令牌」。\n创建成功后，会看到类似这样的 Token：\nsntrys_************Yt8k\n\n这个 Token 就是我们要填到 .env.production 文件里的 VITE_SENTRY_AUTH_TOKEN。\n一点点建议\n这个 Token 只显示一次，请复制保存好；\n不要提交到 Git 仓库，建议通过 CI 环境变量注入；\n权限只勾选 org:ci 就够用，不建议勾选太多；\n6.执行打包并验证上传效果\n前面的配置完成之后，我们就可以正式打包项目，并将 .map 文件上传到 Sentry 了。\n在项目根目录执行打包命令：\npnpm build\n\n如果一切配置正确，我们会在控制台中看到类似下面的提示：\nSource Map Upload Report\n\n  Scripts\n    ~/67e49c15-590c-4e25-8b79-388f91742a8e-0.js (sourcemap at index-ByQNq1yw.js.map, debug id 67e49c15-590c-4e25-8b79-388f91742a8e)\n\n  Source Maps\n    ~/67e49c15-590c-4e25-8b79-388f91742a8e-0.js.map (debug id 67e49c15-590c-4e25-8b79-388f91742a8e)\n\n[sentry-vite-plugin] Info: Successfully uploaded source maps to Sentry\n\n这说明：SourceMap 上传成功，Sentry 已经接收了我们打包后的 .map 文件，并关联到了对应的 release。\n如果我们配置了：\ndeleteAfterCompile: true\n\n或者在构建命令后手动加了 .map 清理命令，那么构建完成后，.map 文件会被删除，防止误部署到线上。\n我们可以执行以下命令检查：\nls dist/**/*.map\n\n如果终端提示为空（或者没有任何输出 / 提示文件找不到），说明 .map 文件已经被自动清理干净了。\n这样，当我们的项目打包上线后，如果线上出现错误，再去 Sentry 查看报错详情时，堆栈信息就会像本地开发时一样清晰。我们就能直接看到具体的文件名、函数名和代码行号，而不会再只看到那些压缩后的文件路径和混淆变量。\n有关release的说明，sourcemap 能不能生效就看它了\n在使用 Sentry 的 SourceMap 功能时，有一个非常关键但又容易被忽略的前提：上传 SourceMap 时指定的 release，必须和我们代码里 Sentry SDK 初始化时的 release 完全一致。\n我们可以把 release 理解为我们项目的版本号。每一次打包部署，都是一次 release。\n如果我们打包时用了一个 release，结果初始化 SDK 时用了另一个，那抱歉，即使我们成功上传了 .map 文件，Sentry 也没法把错误堆栈还原成源码，只能告诉我们：\nchunk-abc123.js:1:1729\n\n所以，我们必须确保这两个地方的 release 保持一致。\n为了防止这类问题，我采用了构建时统一生成 release 的方式，并在代码中注入一个全局变量 __RELEASE__，确保 Sentry 插件上传 SourceMap 和 SDK 初始化用的是同一个版本号。\n第一步：在 vite.config.ts 中构造 release 并注入\n我们读取 VITE_SENTRY_PROJECT 作为项目名，配合当前 Git 提交的哈希值，组合成一个 release，例如：\nsentry_demo_vue@a1b2c3d\n\n然后通过 define 注入到全局变量中：\ndefine: {\n  __RELEASE__: JSON.stringify(`${project}@${version}`),\n}\n\n并同时用于配置 sentryVitePlugin 插件上传：\nsentryVitePlugin({\n  release: `${project}@${version}`,\n  ...\n})\n\n第二步：在 Sentry.init() 中使用 __RELEASE__\n初始化 SDK 时，我们不再手动拼 release，而是直接使用刚才注入的变量：\nSentry.init({\n  release: __RELEASE__,\n  ...\n})\n\n这样无论我们在哪个环境构建，版本号都自动带上了当前的 Git 版本，既统一又不容易出错。\n第三步：在 env.d.ts 中声明变量\n为了让 TypeScript 识别这个全局变量，我们加了一行类型声明：\ndeclare const __RELEASE__: string;\n\n构建后的项目在上传 SourceMap 时自动使用当前 git 版本，Sentry SDK 上报时也使用同样的版本号。\n总结一句话：Sourcemap 能不能生效，release 一致是前提。\nSentry埋点\n在实际项目中，我们做埋点往往不是为了凑功能或者“形式上有就行”，而是为了更好地还原用户行为轨迹、分析问题来源、辅助产品决策、提升整体体验。\n我们可以从几个常见的场景来看，哪些地方用得上埋点：\n1. 用户行为异常分析\n有时候我们只知道某个页面报错了，但不知道用户是怎么操作的才触发这个错误。\n比如：\n如果我们在关键操作、页面跳转等地方都加了埋点，那就能清楚地知道：\n用户先打开了哪个页面\n之后点了哪些按钮\n最后在什么操作后出现了异常\n这在做线上问题定位、还原用户操作路径时非常重要，特别是配合 Sentry 这类错误监控工具中的「面包屑」功能，效果更明显。\n2. 活动页面点击统计 / 转化分析\n在活动运营中，埋点更是刚需。\n比如一个节日活动页面上线了，运营可能会问：\n有多少人打开了这个页面？\n弹窗展示了多少次？有多少人点了“立即参与”按钮？\n最终提交表单的人有多少？和点击的人比，转化率是多少？\n这些数据平时并不会自动记录在系统里，需要我们在页面中通过埋点记录：\n页面曝光\n按钮点击\n表单提交\n最终才能做出转化漏斗分析，判断活动效果。如果没有埋点，就等于活动做完了，但不知道效果如何，下一次也无从优化。\n3. 功能使用率评估\n有一些功能上线后，看起来“做完了”，但实际有没有人用、用得多不多，其实系统本身不会告诉我们的。\n比如我们上线了一个“收藏”功能、一键生成配置功能等，那我们可能会好奇：\n有多少用户点过这个功能？\n他们点的时候是在哪个页面？\n是不是位置太隐蔽了，大家都没发现？\n这种情况下，如果我们事先加了埋点，就能清晰看到使用情况，如果发现点击量非常少，就能反过来推动：\n改位置\n加引导\n甚至考虑是否下线这个功能\n所以很多时候，埋点也起到了“帮助产品做决策”的作用。\n4. 页面性能与路径优化\n更进一步的埋点，我们还可以配合页面性能分析。\n比如：\n记录用户从首页点击“立即购买”到真正进入支付页，一共用了多久？\n是不是在中间某个页面加载得特别慢？\n通过在关键页面加载完成时打点，再记录时间差，我们就可以发现瓶颈，进行页面或接口的性能优化。\n示例：用户行为异常埋点分析\n在前面的内容中，我们提到了可以通过在路由中埋点的方式，记录用户的行为路径，方便后续定位问题。比如下面这段代码：\nrouter.afterEach((to, from) => {\n  const toTitle = to.meta.title || to.name || to.fullPath\n  const fromTitle = from.meta?.title || from.name || from.fullPath || '(无来源)'\n\n  addSentryBreadcrumb({\n    category: 'navigation',\n    message: `从【${fromTitle}】进入【${toTitle}】`,\n    data: {\n      from: from.fullPath,\n      to: to.fullPath,\n    }\n  })\n\n  document.title = `${toTitle} - MyApp`\n})\n\n这段代码的作用很简单：每当用户路由跳转时，就自动添加一条导航相关的面包屑信息，包括来源页面和目标页面。这条信息会被 Sentry 记录下来，作为用户行为轨迹的一部分。\n模拟一次异常流程\n我们啦做一个简单的测试：\n用户先从首页进入“关于我们”页面；\n然后点击跳转到“错误页面”；\n在错误页面中主动抛出一个异常。\n这时候我们再打开 Sentry 后台，查看错误详情，可以看到下图中记录的错误信息：\n\n第一条是抛出的异常信息；\n再往下就是用户触发异常之前的行为记录，比如从“关于我们”进入“错误页面”。\n查看完整的用户行为链路\n为了进一步分析问题，我们可以点击 View 6 more 展开完整的面包屑日志：\n\n在这个面板中，我们能清晰看到整个操作链路：\n用户从首页进入了“关于我们”；\n然后从“关于我们”跳转到了“错误页面”；\n最终触发了异常。\n通过这样的导航面包屑，我们就能非常直观地还原用户的操作过程，判断异常是否与某一步操作有关，从而帮助我们快速复现并定位问题。这也是“用户行为异常埋点”的一个实际应用场景。\n开启用户行为录制：还原错误发生前的真实场景\n虽然我们在上一节中已经通过 addSentryBreadcrumb() 记录了用户的一些关键行为路径，比如用户点击了哪些按钮、跳转了哪些页面等等，这些信息已经可以帮助我们初步还原用户操作链路。\n但在实际排查中，我们有时仍然会遇到这种情况：\n用户反馈某个操作卡住了，但没有明确报错日志，甚至连 Sentry 都没捕捉到异常。\n我们看到的面包屑记录是：“进入页面 -> 点击按钮”，中间过程缺失，还是无法判断究竟是哪一步出了问题。\n这时候，如果我们能把用户当时的页面操作录像下来，就能更精准地还原整个流程，更快速定位问题。这正是 Sentry 提供的 Replay 录屏功能 的作用。\n一、安装依赖\n要使用 Sentry 的屏幕录制功能（Replay），我们需要安装两个包：\npnpm add @sentry/vue @sentry/replay\n\n二、如何开启 Sentry Replay 录制功能？\n我们可以通过配置 @sentry/vue 提供的 replayIntegration() 模块，来快速启用该功能。核心逻辑如下：\n修改 src/sentry.ts 中的初始化代码\nimport * as Sentry from \"@sentry/vue\";\nimport { browserTracingIntegration, replayIntegration } from \"@sentry/vue\";\nimport type { App } from \"vue\";\nimport router from \"./router\";\n\nexport function setupSentry(app: App) {\n  Sentry.init({\n    app,\n    dsn: import.meta.env.VITE_SENTRY_DSN,\n    environment: import.meta.env.MODE || \"development\",\n    release: __RELEASE__,\n    debug: true,\n\n    integrations: [\n      browserTracingIntegration({ router }),\n      replayIntegration({\n        maskAllText: false,     // 是否对所有文本打码（false 表示原样录入）\n        blockAllMedia: false    // 是否屏蔽图像、视频、SVG 等（false 表示保留媒体）\n      }),\n    ],\n\n    // 性能采样设置\n    tracesSampleRate: 1.0,\n\n    // Replay 录像设置\n    replaysSessionSampleRate: 0.0,   // 普通会话是否录像（设为 0 表示不录像）\n    replaysOnErrorSampleRate: 1.0,   // 错误发生时是否录像（设为 1 表示100%录像）\n  });\n\n  // 省略：全局 errorHandler、Promise rejection、主动上报等逻辑...\n}\n\n三、录制策略说明\nreplaysSessionSampleRate: 控制普通用户访问页面时是否录像，建议在生产环境设为 0.0，避免过多无用录像。\nreplaysOnErrorSampleRate: 控制发生 JS 报错、Promise 拒绝等错误时是否开启录制。建议设为 1.0，即每次出错都能录像。\n这样可以有效地将录像资源集中在真正出现问题的会话上，提高定位效率。\n四、如何验证是否成功开启？\n重启项目 → 打开控制台 → 手动触发一个 JS 报错，比如：\nthrow new Error(\"这是一个测试错误\");\n\n然后我们会在 Sentry 控制台中看到新的报错事件，这时候：\n页面右侧出现一个【Replay】按钮。\n\n2.  点击后即可播放用户在该报错发生前后的操作录像。\n\n右下角还会有一个【See full replay】按钮，点击可以切换到完整录像页面。\n\n同时我们也会看到报错发生前后的【Breadcrumb】面包屑操作记录，比如页面跳转、按钮点击等行为。这样就可以帮助我们从“用户视角”真正还原问题现场。\n五、更多高级配置项（可选）\nSentry 提供了更丰富的配置能力，比如：\n\n配置项说明\n\nmaskAllText是否对页面所有文本内容打码（防止敏感数据泄露）\nblockAllMedia是否屏蔽页面中的图片、视频、canvas 等内容\nnetworkDetailAllowUrls可选：采集请求详情（如 API 请求）\nidentifyUser()推荐结合 Sentry.setUser(...) 在登录后设置用户 ID，方便后续排查是谁遇到了问题\nSentry.addBreadcrumb()可选：在关键行为处手动添加操作记录（行为日志）\n\n通过启用 @sentry/vue 提供的 Replay 功能，我们可以在出错时自动录制用户行为，大幅提升排查效率。结合已有的日志上报、用户 ID、标签与面包屑操作记录，我们能更完整地还原真实使用场景，做到“看得见问题”。\n页面性能监控：不仅能看到错误，还能看到哪里慢了\n我们前面已经实现了错误上报、面包屑埋点和屏幕录制，基本能定位大部分异常情况。\n但有时候用户并不会报错，只是觉得页面加载慢、跳转卡顿或者某个页面总是半天才出来。这类“没报错但体验不好”的问题，如果我们没有性能监控，是很难发现的。\n这个时候，我们可以启用 Sentry 的页面性能监控功能，来帮助我们记录：\n页面加载时间（比如首屏渲染用了多久）\n路由跳转耗时\n请求接口的耗时\n页面初始化过程中每一段逻辑的时间消耗\n只要在初始化的时候加上 browserTracingIntegration 插件，就能自动采集这些信息。\n安装依赖\n如果还没安装性能监控相关的依赖，需要先补一下：\npnpm add @sentry/vue @sentry/tracing\n\n添加性能监控配置\n打开 setupSentry() 初始化方法，在 integrations 数组里加上：\nimport { browserTracingIntegration } from '@sentry/vue'\n\nSentry.init({\n  // ...其他配置省略\n  integrations: [\n    browserTracingIntegration({\n      router, // 配置 vue-router 实例，自动记录路由跳转耗时\n    }),\n  ],\n\n  // 设置性能采样率（开发环境建议 1.0，生产建议 0.1）\n  tracesSampleRate: 1.0,\n})\n\n这样配置之后，Sentry 就会自动帮我们记录每一次页面加载和跳转的耗时信息。\n在哪里能看到这些数据？\n配置好之后，进入 Sentry 控制台，点击左边导航的 “Performance” 或 “性能” 菜单，我们会看到每一次页面加载都被记录成了一条“事务（Transaction）”。\n每条事务会显示页面加载过程中各个阶段的耗时情况，比如：\nDOM 渲染用了多久\n路由跳转用了多久\n图片 / 视频 / 接口加载花了多长时间\n哪些任务是最耗时的\n我们可以直接点进来查看详细的耗时分析图，定位“到底慢在哪里”。\n上面实操部分我用的不多就不举例了，加上性能监控之后，我们就能做到：\n不光知道“哪里出错了”，还能知道“哪里慢了”\n能从页面加载细节里找到性能瓶颈\n帮助前端在没有用户投诉的情况下，提前发现体验问题\n到这一步，整个前端监控体系就比较完整了。我们不仅能看到错误、知道用户做了什么、还能还原他们的操作流程，甚至还能判断性能好不好。\n关于Sentry报警\n除了错误上报、性能监控、用户行为录屏这些能力，我们还可以借助 Sentry 配置「报警通知」。\nSentry 支持我们设置一些规则，比如：某个错误首次出现、在短时间内重复出现多次、或影响的用户数量较多等情况时，自动触发告警。\n目前默认是通过邮件来发送通知，配置起来也比较简单。如果我们想把报警信息同步到团队使用的工具，比如 Slack、飞书、Discord、企业微信等，也可以在后台的集成中心中，安装并配置对应的集成插件。\n不过需要注意的是，部分通知渠道（比如 Webhook 或企业应用）可能需要更高的权限或私有化部署支持。如果我们只是用默认的云服务版本，那通常只支持部分渠道（比如邮件、Slack）直接接入。\n总的来说，Sentry 的告警通知功能，适合和日常的监控流程搭配使用，帮助我们在异常发生的第一时间就收到提醒，快速定位并响应问题。\n关于Sentry部署\n前面我们演示的 Sentry 接入、错误上报、录屏、性能监控等功能，都是基于官方提供的云端版本（sentry.io）来进行的。\n这种方式适合快速试用，不需要我们自己搭建，也省去了维护服务器、数据库的麻烦。但也有一些限制，比如：\n有些功能（如完整的 Webhook 通知、自定义数据保留时长）只有付费套餐才支持；\n数据存在 Sentry 的服务器上，可能不太适合对数据安全要求高的项目；\n无法根据我们自己的业务场景做一些深度定制。\n如果项目对隐私、权限或者功能控制有更高要求，Sentry 也支持“私有化部署”。我们可以自己部署一个 Sentry 服务，所有数据保存在自己的服务器上。\n实际中我们最常见的部署方式有：\nDocker：官方提供了基于 Docker 的部署方案（develop.sentry.dev/self-hosted… Docker，就可以一键拉起整个服务；\n手动部署：适用于对环境要求更细的公司，比如手动安装 PostgreSQL、Redis、Kafka、Symbolicator 等组件，然后运行 Sentry；\n云服务商镜像：也可以从一些云平台的镜像市场上获取现成的 Sentry 部署包，比如 AWS、GCP 上可能会有官方或第三方的镜像。\n不过部署 Sentry 的门槛相对还是偏高一些，对运维资源有一定要求。所以如果只是中小型项目、团队人手不多，优先使用云端版本会更加方便。\n这里由于写的太多了我就不再一步一步来部署一遍了。不会部署的同学可以看下其他有关的文章跟着搞一下 其实也不难的。\n其他：部署在公网时的一点小建议：加一层 Nginx + HTTPS 反向代理更稳妥\n一般我们在部署 Sentry 到公网时，都会单独配置一个二级域名（比如 sentry.xxx.com），然后通过 Nginx 做一层反向代理，并加上 HTTPS 证书，确保访问安全。\n如果我们只是通过 IP 地址访问，比如 http://123.123.123.123:9000，不仅会被浏览器提示“不安全连接”，而且线上项目调用时也可能因为协议不一致（HTTP 和 HTTPS 混用）被浏览器拦截，甚至影响 Sentry 的上报。\n所以更推荐的做法是：\n配一个好记的二级域名，比如 sentry.mycompany.com；\n用 Nginx 做一层反向代理，把外部请求转发到 Sentry 实际运行的 localhost:9000；\n再配一个 HTTPS 证书（可以使用 Let’s Encrypt 免费证书）；\n开启 80 → 443 自动跳转，确保用户始终走 HTTPS。\n这样做不仅更安全，浏览器和 SDK 的请求也更顺畅，还能防止接口报 mixed content 错误。这个我也不讲具体操作了。反正也不难，我这篇写的太多了就不细讲了。ip部署有问题的可以看下其他相关文章 写的很棒的。\n结语\n回到开头，其实我们一开始其实就是在思考这个问题：\n前端有没有必要接入 Sentry 这类监控平台？\n其实很多团队对前端监控这块的投入确实不多，常见理由无非是“没什么错误”、\"出了问题也能看到控制台\"、“又不是后端服务挂了影响业务”……\n但是我们这篇内容通过实际接入和配置，大概也已经看到了 Sentry 的这些能力：\n可以记录详细的 JS 报错信息，堆栈定位非常清晰；\n通过 Source Map 还原源码，准确找到是哪一行代码报错；\n面包屑功能可以帮我们分析用户触发错误前的操作链路；\n录屏功能能完整还原用户操作过程，方便我们复现 bug；\n能设置错误报警通知，第一时间知道哪里出问题了；\n如果部署在自有服务器上，还能满足企业内部的合规需求。\n这么一看，其实前端接入 Sentry 不仅“有必要”，而且是非常值得做的一件事。它不仅能提升前端排查问题的效率，还能让团队整体对线上问题的掌控力大大增强。\n虽然我们一直强调用技术实现“降本增效”，能节省的就尽量省，但前端监控这类影响线上稳定性和用户体验的能力，是不能省的。\n很多时候，一个难复现的前端 bug，可能会花掉开发、测试、运营三方大量时间。与其靠人力去定位和还原，不如一开始就接入好监控工具，把排查和追踪的成本降下来。\n如果我们是个人开发者，Sentry 提供的免费额度已经够用；如果是企业团队，用 Docker 自建也不复杂。\n与其被动应对报错，不如主动掌握问题的第一现场。这，就是前端接入 Sentry 的价值所在。",
      "hotIndex": 17,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7563858353883775015",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "见过哪些醍醐灌顶的Java代码：从\"卧槽\"到\"原来如此\"的顿悟",
      "url": "https://juejin.cn/post/7563858353883775015",
      "pubDate": "Thu, 23 Oct 2025 00:26:38 GMT",
      "description": "大家好，我是晓凡\n\"代码写出来是给人看的，顺便能在机器上运行\"——某位秃顶程序员\n还记得第一次看JDK源码时的那种震撼吗？\n就像刘姥姥进了大观园，眼花缭乱的同时不禁感叹：\"原来代码还能这么写！\n\"今天咱们就来聊聊那些让我等凡夫俗子眼前一亮的Java代码，保证看完让你直呼\"醍醐灌顶\"。\n一、Lambda表达式\n还记得Java 8之前的匿名内部类吗？那代码长得跟老太太的裹脚布一样，又臭又长。看看这个经典的多线程例子：\n// Java 8之前\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Hello from a thread\");\n    }\n}).start();\n\n// Java 8之后\nnew Thread(() -> System.out.println(\"Hello from a thread\")).start();\n\n第一次看到这种写法时，不禁感慨也太简洁了吧！Lambda表达式不仅仅是语法的简化，更是一种思维方式的转变——从\"怎么做\"到\"做什么\"。\n再来看看集合操作的蜕变：\n// 传统写法：循环遍历\nList<String> names = new ArrayList<>();\nfor (User user : users) {\n    if (user.getAge() > 18) {\n        names.add(user.getName());\n    }\n}\n\n// Lambda写法：声明式编程\nList<String> names = users.stream()\n    .filter(user -> user.getAge() > 18)\n    .map(User::getName)\n    .collect(Collectors.toList());\n\n这代码读起来就像在读英文：\"过滤出年龄大于18岁的用户，然后映射到他们的名字，最后收集成列表\"。这种写法不仅简洁，更重要的是它表达了\"做什么\"而不是\"怎么做\"。\n二、Stream API：数据处理的\"流水线\"\nStream API绝对是Java 8最耀眼的明星之一。它让数据处理变得像工厂流水线一样优雅。看看这个复杂的业务场景：\n// 计算订单总额，排除已取消的订单，按用户分组，计算每个用户的订单总金额\nMap<Long, Double> userOrderTotals = orders.stream()\n    .filter(order -> order.getStatus() != OrderStatus.CANCELLED)\n    .collect(Collectors.groupingBy(\n        Order::getUserId,\n        Collectors.summingDouble(Order::getTotalAmount)\n    ));\n\n要是用传统写法，这段逻辑起码得写20行代码，而且读起来像在看天书。Stream API的另一个牛逼之处在于它的惰性求值特性：\n// 这行代码什么都不会打印，因为Stream是惰性的\nStream<Integer> stream = Stream.of(1, 2, 3)\n    .peek(System.out::println);\n\n// 只有遇到终端操作时才会执行\nstream.count(); // 现在才会打印1,2,3\n\n这种设计模式简直就是编程界的\"拖延症\"——不到万不得已，绝不执行。但正是这种\"懒惰\"，让Stream能够进行各种优化，比如合并操作、短路求值等。\n三、Optional：告别NullPointerException\n每个Java程序员都经历过NullPointerException的毒打，那种debug的痛苦简直堪比拔牙。\nOptional的出现就像一道光，照亮了null处理的黑暗角落：\n// 传统写法：层层判空\nif (user != null) {\n    Address address = user.getAddress();\n    if (address != null) {\n        String city = address.getCity();\n        if (city != null) {\n            return city.toUpperCase();\n        }\n    }\n}\nreturn \"UNKNOWN\";\n\n// Optional写法：链式调用\nreturn Optional.ofNullable(user)\n    .map(User::getAddress)\n    .map(Address::getCity)\n    .map(String::toUpperCase)\n    .orElse(\"UNKNOWN\");\n\nOptional的强大之处在于它强迫你思考null的情况，而不是假装它不存在：\n// 更复杂的例子\nOptional<User> result = users.stream()\n    .filter(u -> u.getAge() > 25)\n    .findFirst()\n    .flatMap(this::findManager)\n    .filter(m -> m.getDepartment().equals(\"IT\"))\n    .map(Manager::getAssistant);\n\n这种链式调用让复杂的逻辑变得清晰可见，每一步都有明确的意图。\n四、设计模式\n4.1 策略模式：告别if-else地狱\n还记得被if-else支配的恐惧吗？策略模式就是来拯救我们的：\n来看看下面价格计算服务 - 展示传统写法与策略模式的对比\n// ==================== 传统写法：if-else地狱 ====================\n/**\n * 使用传统的if-else结构来计算折扣价格\n * 缺点：\n * 1. 当折扣类型增加时，需要不断修改这个方法（违反开闭原则）\n * 2. 代码冗长，可读性差\n * 3. 不易于维护和扩展\n * 4. 测试困难，需要考虑所有分支情况\n */\npublic double calculatePrice(String type, double price) {\n    // VIP客户享受8折优惠\n    if (\"VIP\".equals(type)) {\n        return price * 0.8;\n    // 普通会员享受9折优惠\n    } else if (\"MEMBER\".equals(type)) {\n        return price * 0.9;\n    // 新用户享受95折优惠\n    } else if (\"NEW\".equals(type)) {\n        return price * 0.95;\n    }\n    // 默认不打折\n    return price;\n}\n\n// ==================== 策略模式写法 ====================\n\n/**\n * 折扣策略接口\n * 定义了计算折扣价格的统一接口\n * 所有具体的折扣策略都需要实现这个接口\n */\npublic interface DiscountStrategy {\n    /**\n     * 计算折扣后的价格\n     * @param price 原始价格\n     * @return 折扣后的价格\n     */\n    double calculate(double price);\n}\n\n/**\n * 折扣上下文类\n * 负责管理和选择合适的折扣策略\n * 使用Spring的@Service注解标记为服务组件\n */\n@Service\npublic class DiscountContext {\n    // 存储所有折扣策略的映射表，key为策略名称，value为策略实例\n    private final Map<String, DiscountStrategy> strategies;\n    \n    /**\n     * 构造函数\n     * 初始化所有可用的折扣策略\n     * @param strategyList Spring容器中所有实现了DiscountStrategy接口的Bean列表\n     */\n    public DiscountContext(List<DiscountStrategy> strategyList) {\n        // 将策略列表转换为Map，方便根据类型快速查找\n        this.strategies = strategyList.stream()\n            .collect(Collectors.toMap(\n                // Key: 从类名提取策略类型名称\n                // 例如：\"VipStrategy\" -> \"vip\"\n                s -> s.getClass().getSimpleName().replace(\"Strategy\", \"\").toLowerCase(),\n                // Value: 策略实例本身\n                Function.identity()\n            ));\n    }\n    \n    /**\n     * 根据用户类型计算折扣价格\n     * @param type 用户类型（如\"vip\", \"member\", \"new\"）\n     * @param price 原始价格\n     * @return 折扣后的价格\n     */\n    public double calculatePrice(String type, double price) {\n        // 使用Optional避免空指针异常\n        return Optional.ofNullable(strategies.get(type.toLowerCase()))\n            // 如果找到对应的策略，则执行计算\n            .map(strategy -> strategy.calculate(price))\n            // 如果未找到对应策略，则返回原价\n            .orElse(price);\n    }\n}\n\n// ==================== 策略模式的优势 ====================\n/*\n * 1. 开闭原则：添加新的折扣策略时无需修改现有代码\n * 2. 单一职责：每个策略类只负责一种折扣计算逻辑\n * 3. 易于测试：每个策略可以独立测试\n * 4. 易于扩展：只需要新增策略类并注册到Spring容器即可\n * 5. 可读性强：逻辑清晰，易于理解和维护\n */\n\n\n这种写法不仅消除了if-else，更重要的是它遵循了开闭原则：新增一种折扣策略时，只需要添加一个新的策略类，而不需要修改原有代码。\n4.2 建造者模式\n当对象的属性多到让人头皮发麻时，建造者模式就是救星：\n// 传统写法：构造函数参数爆炸\nUser user = new User(\"张三\", 25, \"男\", \"13800138000\", \"zhangsan@qq.com\", \n    \"北京市朝阳区\", \"程序员\", 3, \"本科\", \"清华大学\", ...);\n\n// 建造者模式：链式调用\nUser user = User.builder()\n    .name(\"张三\")\n    .age(25)\n    .gender(\"男\")\n    .phone(\"13800138000\")\n    .email(\"zhangsan@qq.com\")\n    .address(\"北京市朝阳区\")\n    .profession(\"程序员\")\n    .experience(3)\n    .education(\"本科\")\n    .school(\"清华大学\")\n    .build();\n\n这种写法不仅可读性大大提高，而且避免了构造函数参数过多的问题。更重要的是，它可以轻松处理可选参数的问题。\n五、并发编程：从\"线程安全\"到\"性能艺术\"\n5.1 异步编程的利器\n还记得被Future.get()阻塞的痛苦吗？CompletableFuture让异步编程变得优雅：\n// 传统写法：阻塞等待\nFuture<String> future = executor.submit(() -> fetchDataFromRemote());\nString result = future.get(); // 阻塞等待\n\n// CompletableFuture：真正的异步\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> fetchDataFromRemote())\n    .thenApply(data -> processData(data))\n    .thenCompose(processed -> CompletableFuture.supplyAsync(() -> saveToDatabase(processed)))\n    .exceptionally(ex -> {\n        log.error(\"处理失败\", ex);\n        return \"默认值\";\n    });\n\n// 非阻塞地处理结果\nfuture.thenAccept(result -> System.out.println(\"结果：\" + result));\n\n这种链式调用让复杂的异步逻辑变得清晰可见，而且完全不会阻塞线程。\n5.2 线程安全\nJava并发包中的集合设计简直就是艺术品：\n// ConcurrentHashMap：分段锁的杰作\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n\n// 原子操作，无需外部同步\nmap.compute(\"key\", (k, v) -> v == null ? 1 : v + 1);\n\n// CopyOnWriteArrayList：读多写少的神器\nCopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\nlist.add(\"元素\"); // 写操作会复制底层数组\nString element = list.get(0); // 读操作无锁，性能极高\n\n这些并发集合的设计充分体现了\"分离关注点\"的原则，让不同的操作在不同的场景下都能达到最佳性能。\n六、函数式编程\nJava 8引入的函数式编程特性，让我们的代码更加优雅：\n// 高阶函数：函数作为参数\npublic <T> List<T> filter(List<T> list, Predicate<T> predicate) {\n    return list.stream()\n        .filter(predicate)\n        .collect(Collectors.toList());\n}\n\n// 使用：传递行为而不是数据\nList<String> longNames = filter(names, name -> name.length() > 5);\nList<Integer> evenNumbers = filter(numbers, n -> n % 2 == 0);\n\n// 柯里化：函数的多重变身\nFunction<Integer, Function<Integer, Integer>> add = x -> y -> x + y;\nFunction<Integer, Integer> add5 = add.apply(5);\nSystem.out.println(add5.apply(3)); // 输出8\n\n这种编程范式让我们能够用更抽象的方式来思考问题，代码变得更加简洁和富有表达力。\n七、写出让人\"哇塞\"的代码\n7.1 方法链的艺术\n// 糟糕的设计\nvalidator.validate(user);\nif (validator.isValid()) {\n    repository.save(user);\n    emailService.sendWelcomeEmail(user);\n    logService.logUserRegistration(user);\n}\n\n// 优雅的设计\nValidationResult result = validator.validate(user)\n    .onSuccess(repository::save)\n    .onSuccess(emailService::sendWelcomeEmail)\n    .onSuccess(logService::logUserRegistration);\n\nif (result.hasErrors()) {\n    handleValidationErrors(result.getErrors());\n}\n\n7.2 异常处理的优雅方式\n// 传统的try-catch-finally\ntry {\n    resource1 = acquireResource1();\n    try {\n        resource2 = acquireResource2();\n        // 业务逻辑\n    } finally {\n        if (resource2 != null) resource2.close();\n    }\n} finally {\n    if (resource1 != null) resource1.close();\n}\n\n// try-with-resources：自动资源管理\ntry (Resource1 r1 = acquireResource1();\n     Resource2 r2 = acquireResource2()) {\n    // 业务逻辑\n} // 资源自动关闭，无需finally\n\n八、结语：代码的修行之路\n看完这些例子，你可能会说：\"卧槽，原来代码还能这么写！\"\n但我想说，这只是冰山一角。编程就像修行，每一次顿悟都是一次成长。\n所以，下次写代码的时候，不妨多想想：这段代码十年后还有人愿意维护吗？\n如果答案是肯定的，那你就是真正的编程大师了。\n最后，用一句话与大家共勉：\"代码不是写给机器看的，是写给下一个维护你的人看的——而那个人很可能就是未来的你。\"",
      "hotIndex": 18,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7563860666349862962",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "OCR的新高度？PaddleOCR-VL 与 DeepSeek-OCR 的技术与应用横评",
      "url": "https://juejin.cn/post/7563860666349862962",
      "pubDate": "Wed, 22 Oct 2025 12:53:36 GMT",
      "description": "一、OCR 重回 C 位：大模型的“关键感知器”\n这两天技术圈又炸了——DeepSeek 又双叒发布新模型，这次还带了个看似“熟悉”的技术关键词：DeepSeek-“OCR”。\n如果最近有在关注视觉理解方向的朋友，会发现一个有趣的现象：整个 OCR 赛道突然热了起来。\n近一个月内，DeepSeek、百度、上海 AI Lab 等团队几乎在同一时间抛出自家的新一代 OCR 模型，10 月 21 日，HuggingFace 全球模型趋势榜前三名全部被 OCR 模型包揽，一时间，“OCR” 成了新的技术高地。\n\n其中，尤其引人注目的是，百度飞桨团队开源的 PaddleOCR-VL 模型持续登顶 Trending 榜首（连续5天登顶HF trending第一；同时登陆Modelscope trending全球第一；HuggingPaper Trending 全球第一；GitHub Python 总榜第3、全球总榜第9），成为当前全球开发者最关注的 OCR 系统之一。\n\n\nPaddleOCR-VL 和 DeepSeek-OCR，虽然都是围绕着 OCR，细致了解之后，才发现他们原来大一不一样，本篇一起来看看两者侧重，以及讨论为什么大模型背景下 OCR 有着如此重要的地位？\n二、PaddleOCR-VL 意在“精准识别”，DeepSeek 意在“文本压缩”，\n简单概括来说，DeepSeek 的目标，是压缩。 它想解决的，是大模型在处理长文本时的“语义冗余”问题——上下文太长、token 太多、推理链太杂，最终导致显存爆炸、成本激增。DeepSeek 希望通过“视觉模态压缩”让模型在保持语义连贯的同时，大幅减少输入 token，让它“少看但懂多”。\n根据介绍，此次开源的 DeepSeek-OCR 由两个部分组成：核心编码器 DeepEncoder 和解码器 DeepSeek3B-MoE-A570M。DeepEncoder 专为在高分辨率输入下保持低计算激活而设计，同时实现高压缩比，以控制视觉 token 数量在可管理的范围内。\n\n而 PaddleOCR-VL 的目标，则是识别。 它是一种 OCR SOTA方案，作为文心4.5的最强衍生模型，基于ERNIE-4.5-0.3B语言模型训练，参数仅0.9B，却爆发出惊人能量，它在OCR性能和实用产业价值上全球第一。PaddleOCR-VL 追求的是尽可能完整地还原图像视觉世界的信息结构。无论是票据、合同、表格、说明书，还是手写体、扫描件、低光照图片，PaddleOCR-VL 都希望在毫厘之间还原每个文字、表格、段落与版式关系。\nPaddleOCR-VL 面对真实世界的各种光照、排版、模糊与噪点，让大模型真正“看清楚”。\n\n现在几乎所有热门应用都离不开 OCR。不管是做 RAG 知识检索、Agent 自动办公，还是像“数字员工”那样去读合同、核对表格，甚至给大模型训练提供高质量语料，都得靠 OCR 打开入口。对于所有大模型来说，如果入口是模糊的、错误的，也只能输出垃圾结论。\n我认为，精准且快速的识别是第一步、通过识别压缩降低成本是第二步，虽然我们要节约成本，但结果不能被“压”成幻觉，不然多少有点舍本逐末了。\n\n三、PaddleOCR-VL 轻量又强大：开发者友好的全场景能力\n我记得，大模型火热之前，百度的OCR技术就很超前，大家会用“百度识图”来识别“植物”等等，如今，百度的 OCR 技术早已不止是一个简单的“识别模型”，而是一整套覆盖多模态感知与语义解析的系统。\n第一代 PaddleOCR 已经成熟，很轻量，能在移动端、云端之间灵活部署，支持印刷体、手写体、多语种、票据、证件、表格等多种场景。并且它设计的相关生态也很完备，从最底层的 PP-OCR 文本检测与识别，到 PP-Structure 的版面结构分析，再到面向文档解析的完整链路，几乎覆盖了 OCR 的全生命周期。\n现在，PaddleOCR 的进化版本 —— PaddleOCR-VL，不再满足于识别字符，而是试图理解图像中的语义关系与空间结构。基于百度的 ERNIE-4.5-0.3B 模型训练，总参数量仅 0.9B，却具备解析复杂文档布局、表格结构、数学公式甚至阅读顺序的能力。\n\n在权威评测基准 OmniBenchDoc V1.5 中，PaddleOCR-VL 以 92.56 分 的综合成绩刷新全球纪录：\n📊 综合性能第一：超越 DeepSeek-OCR-Gundam-M（3B）约 6 分；\n📑 表格理解领先：在表格结构理解（TEDS）与语义理解（TEDS-S）上分别领先 15.5 分 与 9.9 分；\n🧩 阅读顺序更准：编辑误差降低 54% ，符合人类逻辑；\n⚡ 极致轻量化：仅 0.9B 参数，在文本、公式、表格、结构理解四大核心任务上实现全线 SOTA。\n四、实测：PaddleOCR-VL 看“事实”\n光看参数和榜单不如上手测试来得直接。我们用几个真实场景，让你直观感受 PaddleOCR-VL 与 DeepSeek-OCR 的差异。\nPaddleOCR-VL：aistudio.baidu.com/application…\nDeepSeek-OCR：huggingface.co/spaces/axii…\n1、表格识别\n\nDeepSeek-OCR：\n\nPaddleOCR-VL：\n\n对于复杂表格的识别来说，Deepseek-OCR能识别出文字，但莫名其妙多了一列空列，而PaddleOCR-VL 能100%准确识别，太强了！\n2、手写识别：谁更忠于原文\n\nDeepSeek：\n\nPaddleOCR-VL：\n\n在手写文本识别中，PaddleOCR-VL 能精准地区分文字与方格背景，不仅识别出完整的文字内容，连标点符号也能准确还原。DeepSeek-OCR 则出现了识别偏差，将中文误判为日语。\n3、现实照片识别\n\nDeepseek-OCR：\n\nPaddleOCR-VL：\n\nPaddleOCR-VL 能看清红底上的字，而 DeepSeek-OCR 没识别出来文字。\n五、结语：OCR 让 AI 真正“看世界”\n当我们把 DeepSeek-OCR 与 PaddleOCR-VL 放在一起比较时，其实看到的是两个完全不同方向的探索。\nDeepSeek 在做“压缩”，更像是在追求底层算法的极致效率；而 PaddleOCR-VL 在做“识别”，聚焦的是真实场景的可用性，更适合开发者， 让模型“看得更准”，为开发者提供一套真正能落地的OCR视觉理解方案。这两个方向对应当下 AI 发展的两个维度——“内在智能”与“外在感知”。DeepSeek 代表了语言空间的优化与压缩革命，追求更轻、更快、更省；而百度 PaddleOCR-VL 则代表了视觉理解的实用落地，从表格、合同、票据到漫画、照片。\n不论怎样，我们看到了、意识到了 OCR 的重要性，未来的大模型格局，不再被局限于文字、语言的边界，它一定是多模态的，智能体不是参数的堆叠，也不是算力的规模，而是真的“看到、看准、看懂”！\n六、体验地址\n🔗 在线体验：aistudio.baidu.com/application…\n🔗 GitHub：github.com/PaddlePaddl…\n🔗 Hugging Face：huggingface.co/PaddlePaddl…",
      "hotIndex": 19,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    },
    {
      "id": "https://juejin.cn/post/7563860666349649970",
      "source": "掘金热榜",
      "platform": "juejin",
      "category": "tech",
      "title": "微服务正在悄然消亡：这是一件美好的事",
      "url": "https://juejin.cn/post/7563860666349649970",
      "pubDate": "Wed, 22 Oct 2025 11:27:40 GMT",
      "description": "最近在做的事情正好需要系统地研究微服务与单体架构的取舍与演进。读到这篇文章《Microservices Are Quietly Dying — And It’s Beautiful》，许多观点直击痛点、非常启发，于是我顺手把它翻译出来，分享给大家，也希望能给同样在复杂性与效率之间权衡的团队一些参考。\n微服务正在悄然消亡：这是一件美好的事\n为了把我们的创业产品扩展到数百万用户，我们搭建了 47 个微服务。\n用户从未达到一百万，但我们达到了每月 23,000 美元的 AWS 账单、长达 14 小时的故障，以及一个再也无法高效交付新功能的团队。\n那一刻我才意识到：我们并没有在构建产品，而是在搭建一座分布式的自恋纪念碑。\n\n我们都信过的谎言\n五年前，微服务几乎是教条。Netflix 用它，Uber 用它。每一场技术大会、每一篇 Medium 文章、每一位资深架构师都在高喊同一句话：单体不具备可扩展性，微服务才是答案。\n于是我们照做了。我们把 Rails 单体拆成一个个服务：用户服务、认证服务、支付服务、通知服务、分析服务、邮件服务；然后是子服务，再然后是调用服务的服务，层层套叠。\n到第六个月，我们已经在 12 个 GitHub 仓库里维护 47 个服务。我们的部署流水线像一张地铁图，架构图需要 4K 显示器才能看清。\n当“最佳实践”变成“最差实践”\n我们不断告诫自己：一切都在运转。我们有 Kubernetes，有服务网格，有用 Jaeger 的分布式追踪，有 ELK 的日志——我们很“现代”。\n但那些光鲜的微服务文章从不提的一点是：分布式的隐性税。\n每一个新功能都变成跨团队的协商。想给用户资料加一个字段？那意味着要改五个服务、提三个 PR、协调两周，并进行一次像劫案电影一样精心编排的数据库迁移。\n我们的预发布环境成本甚至高于生产环境，因为想测试任何东西，都需要把一切都跑起来。47 个服务在 Docker Compose 里同时启动，内存被疯狂吞噬。\n那个彻夜崩溃的夜晚\n凌晨 2:47，Slack 被消息炸翻。\n生产环境宕了。不是某一个服务——是所有服务。支付服务连不上用户服务，通知服务不断超时，API 网关对每个请求都返回 503。\n我打开分布式追踪面板：一万五千个 span，全线飘红。瀑布图像抽象艺术。我花了 40 分钟才定位出故障起点。\n结果呢？一位初级开发在认证服务上发布了一个配置变更，只是一个环境变量。它让令牌校验多了 2 秒延迟，这个延迟在 11 个下游服务间层层传递，超时叠加、断路器触发、重试逻辑制造请求风暴，整个系统在自身重量下轰然倒塌。\n我们搭了一座纸牌屋，却称之为“容错架构”。\n我们花了六个小时才修复。并不是因为 bug 复杂——它只是一个配置的单行改动，而是因为排查分布式系统就像破获一桩谋杀案：每个目击者说着不同的语言，而且有一半在撒谎。\n那个被忽略的低语\n一周后，在复盘会上，我们的 CTO 说了句让所有人不自在的话：\n“要不我们……回去？”\n回到单体。回到一个仓库。回到简单。\n会议室一片沉默。你能感到认知失调。我们是工程师，我们很“高级”。单体是给传统公司和训练营毕业生用的，不是给一家正打造未来的 A 轮初创公司用的。\n但随后有人把指标展开：平均恢复时间 4.2 小时；部署频率每周 2.3 次（从单体时代的每周 12 次一路下滑）；云成本增长速度比营收快 40%。\n数字不会说谎。是架构在拖垮我们。\n美丽的回归\n我们用了三个月做整合。47 个服务归并成一个模块划分清晰的 Rails 应用；Kubernetes 变成负载均衡后面的三台 EC2；12 个仓库的工作流收敛成一个边界明确的仓库。\n结果简直让人尴尬。\n部署时间从 25 分钟降到 90 秒；AWS 账单从 23,000 美元降到 3,800 美元；P95 延迟提升了 60%，因为我们消除了 80% 的网络调用。更重要的是——我们又开始按时交付功能了。\n开发者不再说“我需要和三个团队协调”，而是开始说“午饭前给你”。\n我们的“分布式系统”变回了结构良好的应用。边界上下文变成 Rails 引擎，服务调用变成方法调用，Kafka 变成后台任务，“编排层”……就是 Rails 控制器。\n它更快，它更省，它更好。\n我们真正学到的是什么\n这是真相：我们为此付出两年时间和 40 万美元才领悟——\n微服务不是一种纯粹的架构模式，而是一种组织模式。Netflix 需要它，因为他们有 200 个团队。你没有。Uber 需要它，因为他们一天发布 4,000 次。你没有。\n复杂性之所以诱人，是因为它看起来像进步。 拥有 47 个服务、Kubernetes、服务网格和分布式追踪，看起来很“专业”；而一个单体加一套 Postgres，看起来很“业余”。\n但复杂性是一种税。它以认知负担、运营开销、开发者幸福感和交付速度为代价。\n而大多数初创公司根本付不起这笔税。\n我们花了两年时间为并不存在的规模做优化，同时牺牲了能让我们真正达到规模的简单性。\n你不需要 50 个微服务，你需要的是自律\n软件架构的“肮脏秘密”是：好的设计在任何规模都奏效。\n一个结构良好的单体，拥有清晰的模块、明确的边界上下文和合理的关注点分离，比一团由希望和 YAML 勉强粘合在一起的微服务乱麻走得更远。\n微服务并不是因为“糟糕”而式微，而是因为我们出于错误的理由使用了它。我们选择了分布式的复杂性而不是本地的自律，选择了运营的负担而不是价值的交付。\n那些悄悄回归单体的公司并非承认失败，而是在承认更难的事实：我们一直在解决错误的问题。\n所以我想问一个问题：你构建微服务，是在逃避什么？\n如果答案是“一个凌乱的代码库”，那我有个坏消息——分布式系统不会修好坏代码，它只会让问题更难被发现。",
      "hotIndex": 20,
      "crawledAt": "2025-10-30T04:16:24.092Z",
      "extra": {}
    }
  ],
  "timestamp": 1761797784092
}